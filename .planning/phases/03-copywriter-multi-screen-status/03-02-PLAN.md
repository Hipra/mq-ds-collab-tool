---
phase: 03-copywriter-multi-screen-status
plan: 02
type: execute
wave: 2
depends_on: [03-01]
files_modified:
  - src/components/ScreenSidebar.tsx
  - src/app/(shell)/page.tsx
  - src/components/PreviewFrame.tsx
  - src/lib/postmessage-types.ts
  - src/stores/inspector.ts
  - src/app/api/preview/[id]/screens/route.ts
autonomous: true
requirements: [SCRN-01, SCRN-02]

must_haves:
  truths:
    - "Left sidebar lists all screen names discovered from the prototype directory"
    - "Clicking a screen name loads that screen in the preview iframe"
    - "Screens can be drag-reordered in the sidebar and the order persists"
    - "Screen names are editable inline and custom names persist"
    - "Sidebar is collapsible to maximize preview space"
  artifacts:
    - path: "src/components/ScreenSidebar.tsx"
      provides: "Collapsible left sidebar with drag-reorder screen list"
      exports: ["ScreenSidebar"]
    - path: "src/app/(shell)/page.tsx"
      provides: "Updated layout with ScreenSidebar left of PreviewFrame"
      min_lines: 30
  key_links:
    - from: "src/components/ScreenSidebar.tsx"
      to: "/api/preview/[id]/screens"
      via: "fetch on mount to load screen list"
      pattern: "fetch.*screens"
    - from: "src/components/ScreenSidebar.tsx"
      to: "src/stores/inspector.ts"
      via: "setActiveScreen dispatches screen change"
      pattern: "setActiveScreen"
    - from: "src/components/PreviewFrame.tsx"
      to: "activeScreenId"
      via: "iframe src includes ?screen= param"
      pattern: "screen"
---

<objective>
Build the multi-screen navigation sidebar — a collapsible left panel listing all prototype screens with drag-to-reorder, inline name editing, and screen switching that reloads the preview iframe.

Purpose: Enables navigation between multiple screens in a prototype, fulfilling SCRN-01 (5-10 screen support) and SCRN-02 (screen navigation in prototype).

Output: ScreenSidebar component, updated page layout, PreviewFrame screen-aware routing.
</objective>

<execution_context>
@/Users/gyorgybokros/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gyorgybokros/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-copywriter-multi-screen-status/03-RESEARCH.md
@.planning/phases/03-copywriter-multi-screen-status/03-01-SUMMARY.md

@src/app/(shell)/page.tsx
@src/components/PreviewFrame.tsx
@src/stores/inspector.ts
@src/lib/postmessage-types.ts
@src/app/api/preview/[id]/screens/route.ts

<interfaces>
<!-- From 03-01: screen discovery API response format -->
Screen API response:
```typescript
// GET /api/preview/[id]/screens
[{ id: string, name: string, file: string }]
```

<!-- From 03-01: inspector store extensions -->
From src/stores/inspector.ts (after 03-01):
```typescript
// Added state:
activeScreenId: string;    // default: 'index'
screens: { id: string; name: string; file: string }[];

// Added actions:
setActiveScreen: (id: string) => void;
setScreens: (screens: { id: string; name: string; file: string }[]) => void;
```

<!-- From existing page.tsx -->
```typescript
// Current layout: Toolbar on top, flex row of PreviewFrame + InspectorPanel
// Phase 3: Add ScreenSidebar as first child of the flex row
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: ScreenSidebar component with dnd-kit sortable and inline name editing</name>
  <files>
    src/components/ScreenSidebar.tsx
  </files>
  <action>
**FIRST: Install dnd-kit dependencies:**
```bash
npm install @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities
```

**Create `src/components/ScreenSidebar.tsx`** — a `'use client'` component.

Props: `{ prototypeId: string }`.

**Layout:**
- Collapsible left sidebar with fixed width (200px) when open, 0px when collapsed
- Toggle button (ChevronLeft/ChevronRight MUI icon) at the top to collapse/expand
- Use a local `useState<boolean>` for `sidebarOpen`, default `true`
- `flexShrink: 0` to prevent flex layout from compressing the sidebar
- Use `Box` with `borderRight: 1, borderColor: 'divider'` for visual separator

**Screen list:**
- On mount, fetch `GET /api/preview/${prototypeId}/screens` to populate the screen list
- Store screens in the Zustand `useInspectorStore` via `setScreens()`
- Read `screens` and `activeScreenId` from the store
- Render each screen as a `ListItemButton` with `selected={screen.id === activeScreenId}`
- Clicking a screen calls `setActiveScreen(screen.id)` on the store

**Drag-to-reorder with dnd-kit:**
```tsx
import { DndContext, closestCenter, PointerSensor, useSensor, useSensors } from '@dnd-kit/core';
import { SortableContext, verticalListSortingStrategy, useSortable, arrayMove } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
```

- Wrap the list in `DndContext` + `SortableContext` with `verticalListSortingStrategy`
- Each screen item uses the `useSortable` hook
- `handleDragEnd`: compute new order with `arrayMove`, update store, persist to metadata via `PATCH /api/preview/${prototypeId}/status` — actually, create a dedicated screen order persistence: `PATCH` to a new inline handler. Simpler approach: POST the new order to `/api/preview/${prototypeId}/screens` as a PATCH. For simplicity, add a PATCH handler to the screens route that accepts `{ order: string[] }` and writes to `metadata.json.screens.order`.

Actually, to keep plan 03-01's screens route read-only and avoid modifying it: persist the order by calling `PATCH /api/preview/${prototypeId}/status` with the extended body `{ screens: { order: [...] } }`. But that conflates concerns. **Better approach:** Add a PATCH handler to `src/app/api/preview/[id]/screens/route.ts` — this file was created in 03-01 with only GET. Add PATCH that accepts `{ order?: string[], customNames?: Record<string, string> }` and updates `metadata.json.screens`.

Create the PATCH handler inline in this task since we're modifying the screens route:
```typescript
export async function PATCH(req, { params }) {
  const { id } = await params;
  const body = await req.json();
  // Read metadata.json, update screens.order and/or screens.customNames, write back
}
```

**Inline name editing:**
- Double-click on a screen name to enter edit mode (local `useState<string | null>` for `editingId`)
- Show a MUI `TextField` (size="small", variant="standard") in edit mode
- On blur or Enter, save the custom name via the PATCH endpoint above with `{ customNames: { [id]: newName } }`
- On Escape, cancel editing

**Empty state:**
- If only one screen (index), show a subtle message: "Add screen-[name].jsx files to create multiple screens"

**Use `PointerSensor`** with `activationConstraint: { distance: 8 }` to prevent drag from interfering with click-to-select and double-click-to-edit.
  </action>
  <verify>
    <automated>cd /Users/gyorgybokros/Projects/mq-ds-collab-tool && npx tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>
    - ScreenSidebar renders a collapsible left sidebar listing screen names
    - Screens are fetched from /api/preview/[id]/screens on mount
    - Clicking a screen selects it in the Zustand store
    - Drag-to-reorder reorders screens and persists order via PATCH
    - Double-click enables inline name editing with persistence
    - Sidebar collapses to zero width with a toggle button
  </done>
</task>

<task type="auto">
  <name>Task 2: Page layout update and PreviewFrame screen-aware routing</name>
  <files>
    src/app/(shell)/page.tsx
    src/components/PreviewFrame.tsx
    src/stores/inspector.ts
  </files>
  <action>
**1. Update `src/app/(shell)/page.tsx`**

Add `ScreenSidebar` as the first child of the flex row (before `PreviewFrame`):

```tsx
import { ScreenSidebar } from '@/components/ScreenSidebar';

// In the flex row:
<Box sx={{ flex: 1, display: 'flex', overflow: 'hidden' }}>
  <ScreenSidebar prototypeId={prototypeId} />
  <PreviewFrame prototypeId={prototypeId} />
  <InspectorPanel />
</Box>
```

Also pass `prototypeId` prop to `Toolbar` (if not already done in 03-01) for the StatusBadge.

**2. Update `src/components/PreviewFrame.tsx`**

Make PreviewFrame react to `activeScreenId` from the Zustand store:
- Import `useInspectorStore` and read `activeScreenId`
- The iframe `src` should include `activeScreenId`: change from `/preview/${prototypeId}` to building the URL with screen awareness
- When `activeScreenId` changes, the preview route needs to know which screen to serve. The preview route (`/preview/[id]/route.ts`) generates the HTML with a `<meta name="bundle-url" content="/api/preview/${id}/bundle">`. To add screen support: update the bundle URL in the meta tag to include `?screen=${screenId}` when not "index".

**Two approaches for screen switching:**

**Approach A (simpler, recommended):** Change the iframe `src` to include a `?screen=` query param. The preview route reads this and embeds it in the bundle-url meta tag. This triggers a full iframe reload on screen switch — acceptable since switching screens is an intentional action, not a live-as-you-type operation.

Update `/preview/[id]/route.ts`:
```typescript
export async function GET(req: NextRequest, { params }) {
  const { id } = await params;
  const screen = req.nextUrl.searchParams.get('screen') || 'index';
  const bundleUrl = screen === 'index'
    ? `/api/preview/${id}/bundle`
    : `/api/preview/${id}/bundle?screen=${screen}`;
  // ... rest same
}
```

In PreviewFrame, build the iframe src:
```typescript
const activeScreenId = useInspectorStore(s => s.activeScreenId);
const screenParam = activeScreenId !== 'index' ? `?screen=${activeScreenId}` : '';
const iframeSrc = `/preview/${prototypeId}${screenParam}`;
```

The iframe should reload when `activeScreenId` changes. Use `key={activeScreenId}` on the iframe to force re-mount, or update the src attribute.

**Also:** When the screen changes, re-fetch the component tree for the new screen. Add a `useEffect` that watches `activeScreenId` and fetches `/api/preview/${prototypeId}/tree?screen=${activeScreenId}` then calls `setComponentTree()` on the store. If this logic already exists in PreviewFrame for the initial load, extend it to re-run on screen change.

**3. Update preview route `src/app/preview/[id]/route.ts`**

Add `?screen=` param reading as described in Approach A above. Pass the screen parameter through to the bundle-url meta tag.

**4. Extend `src/stores/inspector.ts`** (if needed)

If the SSE hot-reload watcher needs to be screen-aware (re-fetch tree for active screen on reload), note this in a comment for future reference but don't modify the watcher — SSE will naturally trigger a full reload which re-fetches the correct screen.
  </action>
  <verify>
    <automated>cd /Users/gyorgybokros/Projects/mq-ds-collab-tool && npx tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>
    - Page layout shows ScreenSidebar | PreviewFrame | InspectorPanel in a flex row
    - Clicking a screen in the sidebar reloads the preview iframe with the selected screen
    - Component tree refreshes when switching screens
    - Preview route passes ?screen= param through to bundle-url meta tag
    - Sidebar collapse removes it from the layout, giving PreviewFrame full width
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no errors
- `npm install` succeeds with dnd-kit packages
- Screen sidebar visible on the left side of the page
- Clicking screen names in sidebar loads different screens in preview
- Drag-reorder works and order persists across page reload
- Sidebar collapse/expand works without layout shift in PreviewFrame
</verification>

<success_criteria>
1. Multi-screen sidebar shows discovered screen files from the prototype directory
2. Screen selection loads the correct screen bundle in the preview iframe
3. Drag-to-reorder and inline name editing both persist to metadata.json
4. Sidebar collapses cleanly without breaking the flex layout
5. Component tree updates to reflect the active screen's component hierarchy
</success_criteria>

<output>
After completion, create `.planning/phases/03-copywriter-multi-screen-status/03-02-SUMMARY.md`
</output>
