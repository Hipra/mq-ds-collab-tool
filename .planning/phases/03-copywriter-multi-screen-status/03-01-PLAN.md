---
phase: 03-copywriter-multi-screen-status
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/StatusBadge.tsx
  - src/components/Toolbar.tsx
  - src/app/api/preview/[id]/status/route.ts
  - src/app/api/preview/[id]/screens/route.ts
  - src/app/api/preview/[id]/bundle/route.ts
  - src/app/api/preview/[id]/tree/route.ts
  - src/app/api/preview/[id]/copy/route.ts
  - src/lib/text-extractor.ts
  - src/lib/copy-overlay.ts
  - src/stores/inspector.ts
  - prototypes/sample/metadata.json
autonomous: true
requirements: [SHAR-03, SCRN-01]

must_haves:
  truths:
    - "Clicking the status badge in toolbar opens a menu with Draft/Review/Approved options"
    - "Selecting a status updates the badge color and persists to metadata.json"
    - "GET /api/preview/[id]/screens returns a list of discovered screen files"
    - "Bundle and tree routes accept ?screen= query param to serve non-default screens"
    - "GET /api/preview/[id]/copy returns extracted text entries from the prototype source"
  artifacts:
    - path: "src/components/StatusBadge.tsx"
      provides: "Chip + Menu status control"
      exports: ["StatusBadge"]
    - path: "src/app/api/preview/[id]/status/route.ts"
      provides: "GET/PATCH status API"
      exports: ["GET", "PATCH"]
    - path: "src/app/api/preview/[id]/screens/route.ts"
      provides: "Screen discovery API"
      exports: ["GET"]
    - path: "src/lib/text-extractor.ts"
      provides: "AST-based text entry extraction"
      exports: ["TextEntry", "extractTextEntries"]
    - path: "src/lib/copy-overlay.ts"
      provides: "Overlay read/write/merge logic"
      exports: ["CopyOverlay", "readOverlay", "patchOverlay", "mergeOverlayIntoEntries"]
  key_links:
    - from: "src/components/StatusBadge.tsx"
      to: "/api/preview/[id]/status"
      via: "fetch PATCH on status change"
      pattern: "fetch.*status"
    - from: "src/app/api/preview/[id]/bundle/route.ts"
      to: "prototype screen files"
      via: "?screen= query param"
      pattern: "screen.*\\.jsx"
---

<objective>
Build the backend APIs and foundational components for Phase 3: status badge with persistence, multi-screen file discovery and routing, text extraction pipeline, and copy overlay logic.

Purpose: Establishes all server-side contracts and the simplest UI feature (status badge) so that Plans 03-02 (screen sidebar) and 03-03 (copy tab) can build their UIs against working APIs.

Output: StatusBadge component in toolbar, status/screens/copy API routes, text extractor lib, copy overlay lib, extended bundle/tree routes with ?screen= support.
</objective>

<execution_context>
@/Users/gyorgybokros/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gyorgybokros/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-copywriter-multi-screen-status/03-RESEARCH.md

@src/lib/ast-inspector.ts
@src/lib/postmessage-types.ts
@src/stores/inspector.ts
@src/components/Toolbar.tsx
@src/app/api/preview/[id]/bundle/route.ts
@src/app/api/preview/[id]/tree/route.ts
@prototypes/sample/metadata.json

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/lib/ast-inspector.ts:
```typescript
export interface PropEntry {
  name: string;
  value: string;
  rawType: 'string' | 'number' | 'boolean' | 'expression' | 'spread';
}

export interface ComponentNode {
  id: string;           // format: "ComponentName_line_col"
  componentName: string;
  props: PropEntry[];
  sourceFile: string;
  sourceLine: number;
  children: ComponentNode[];
}

export function extractComponentTree(sourceCode: string, filePath: string): ComponentNode[];
```

From src/lib/bundler.ts:
```typescript
export async function bundlePrototype(filePath: string): Promise<string>;
export async function getPrototypeSource(filePath: string): Promise<string>;
```

From src/stores/inspector.ts:
```typescript
interface InspectorState {
  panelOpen: boolean;
  activeTab: 'copy' | 'components';
  selectedComponentId: string | null;
  hoveredComponentId: string | null;
  componentTree: ComponentNode[];
  inspectorMode: boolean;
  previewWidth: number | 'auto';
}
```

From src/components/Toolbar.tsx:
```typescript
interface ToolbarProps {
  prototypeName: string;
}
export function Toolbar({ prototypeName }: ToolbarProps);
```

From prototypes/sample/metadata.json:
```json
{
  "name": "Sample Prototype",
  "createdAt": "2026-02-27T00:00:00Z"
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Status badge, status API, and metadata extension</name>
  <files>
    src/components/StatusBadge.tsx
    src/components/Toolbar.tsx
    src/app/api/preview/[id]/status/route.ts
    prototypes/sample/metadata.json
  </files>
  <action>
**1. Create `src/components/StatusBadge.tsx`**

A `'use client'` component that renders a MUI `Chip` that, on click, opens a `Menu` with three `MenuItem` options for status changes.

```typescript
type Status = 'draft' | 'review' | 'approved';

const STATUS_CONFIG: Record<Status, { label: string; color: 'default' | 'warning' | 'success' }> = {
  draft:    { label: 'Draft',    color: 'default' },
  review:   { label: 'Review',   color: 'warning' },
  approved: { label: 'Approved', color: 'success' },
};
```

Props: `{ prototypeId: string }`. On mount, fetch `GET /api/preview/${prototypeId}/status` to load initial status. On selection, call `PATCH /api/preview/${prototypeId}/status` with `{ status: newStatus }`, update local state optimistically.

Use `React.useState` for `anchorEl` (Menu) and `status`. Each MenuItem shows a small Chip + label text. Clicking a MenuItem calls the PATCH endpoint, updates state, and closes the menu.

No confirmation dialog (per CONTEXT.md locked decision). Any-to-any transitions — no sequential enforcement.

**2. Create `src/app/api/preview/[id]/status/route.ts`**

Two handlers:
- `GET`: Read `metadata.json` from `prototypes/[id]/metadata.json`, return `{ status }`. Default to `'draft'` if `status` field is missing.
- `PATCH`: Read request body `{ status: string }`, validate it is one of `'draft' | 'review' | 'approved'`, read existing `metadata.json`, update `status` field, write back. Use `fs.writeFile` with the full JSON (read-modify-write). Return `{ status }`.

Use the same `protoDir` pattern as existing routes:
```typescript
const protoDir = process.env.PROTOTYPES_DIR ?? path.join(process.cwd(), 'prototypes');
```

Set `export const dynamic = 'force-dynamic';`.

**3. Update `prototypes/sample/metadata.json`**

Add `"status": "draft"` field to the existing JSON:
```json
{
  "name": "Sample Prototype",
  "createdAt": "2026-02-27T00:00:00Z",
  "status": "draft"
}
```

**4. Update `src/components/Toolbar.tsx`**

- Import `StatusBadge` from `@/components/StatusBadge`
- Add `prototypeId` to `ToolbarProps` (alongside existing `prototypeName`)
- Render `<StatusBadge prototypeId={prototypeId} />` right after the prototype name Typography, with `sx={{ ml: 1 }}` for spacing
- The Toolbar caller in `page.tsx` already passes `prototypeId` as `prototypeName` — rename prop or add the new prop. Since `prototypeName` is currently hardcoded to `'sample'` in page.tsx and acts as both name and ID, add `prototypeId` as a separate prop to Toolbar. Keep `prototypeName` for display.
  </action>
  <verify>
    <automated>cd /Users/gyorgybokros/Projects/mq-ds-collab-tool && npx tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>
    - StatusBadge renders a colored Chip in the toolbar next to the prototype name
    - Clicking the Chip opens a Menu with Draft/Review/Approved options
    - Selecting an option calls PATCH /api/preview/[id]/status and updates the Chip
    - metadata.json has a status field that defaults to "draft"
    - GET /api/preview/[id]/status returns current status
  </done>
</task>

<task type="auto">
  <name>Task 2: Screen discovery API, bundle/tree route extension, text extraction, and copy overlay</name>
  <files>
    src/app/api/preview/[id]/screens/route.ts
    src/app/api/preview/[id]/bundle/route.ts
    src/app/api/preview/[id]/tree/route.ts
    src/app/api/preview/[id]/copy/route.ts
    src/lib/text-extractor.ts
    src/lib/copy-overlay.ts
    src/stores/inspector.ts
  </files>
  <action>
**1. Create `src/lib/text-extractor.ts`**

Text extraction function using the same Babel AST approach as `ast-inspector.ts`.

```typescript
export interface TextEntry {
  key: string;             // stable: "ComponentName_line_col_propName"
  componentName: string;
  componentPath: string;   // "AppBar > Toolbar > Typography"
  propName: string;        // "children" | "label" | "placeholder" | "aria-label" | "helperText" | "title"
  category: 'visible' | 'placeholder' | 'accessibility';
  sourceValue: string;     // value from JSX source — never mutated
  currentValue: string;    // source value merged with overlay (set after merge)
  sourceLine: number;
  inspectorId: string;     // matches data-inspector-id format: "ComponentName_line_col"
}
```

Use the same `@babel/parser` and `@babel/traverse` imports with the CJS interop pattern from `ast-inspector.ts` (the `@ts-expect-error` + default export interop).

Text-bearing prop categories:
```typescript
const TEXT_PROP_CATEGORIES: Record<string, TextEntry['category']> = {
  children: 'visible',
  label: 'visible',
  helperText: 'visible',
  title: 'visible',
  placeholder: 'placeholder',
  'aria-label': 'accessibility',
};
```

Key generation: `${componentName}_${line}_${col}_${propName}` — where line/col come from `path.node.loc.start`.

The `extractTextEntries(sourceCode: string, filePath: string): TextEntry[]` function:
- Parse with same options as `extractComponentTree`: `sourceType: 'module'`, plugins `['jsx', 'typescript']`, `errorRecovery: true`
- Use a stack to track component path (same pattern as ast-inspector's stack)
- In `JSXElement.enter`: if uppercase component, push name to path stack; iterate `opening.attributes` for JSXAttribute nodes where `name.name` is in TEXT_PROP_CATEGORIES; for StringLiteral values, create a TextEntry
- ALSO handle `JSXText` children: iterate `path.node.children`, for `JSXText` nodes with non-whitespace trimmed content, create a TextEntry with propName `'children'` and category `'visible'`
- In `JSXElement.exit`: pop from path stack (only if uppercase)
- `componentPath` = path stack joined by " > " at the time of extraction
- `inspectorId` = `${componentName}_${line}_${col}` (matches existing data-inspector-id format)
- Set `currentValue = sourceValue` initially (overlay merging happens separately)

**2. Create `src/lib/copy-overlay.ts`**

```typescript
export interface EditHistoryEntry {
  value: string;
  timestamp: string;          // ISO timestamp
}

export interface CopyOverlay {
  version: 1;
  entries: Record<string, {
    editedValue: string;
    editedAt: string;          // ISO timestamp of latest edit
    sourceValueAtEdit: string; // for conflict detection
    edits: EditHistoryEntry[]; // chronological list of all edits (per CONTEXT.md locked decision)
  }>;
}

export async function readOverlay(prototypeId: string): Promise<CopyOverlay>;
export async function patchOverlay(prototypeId: string, key: string, value: string, sourceValue: string): Promise<void>;
export function mergeOverlayIntoEntries(entries: TextEntry[], overlay: CopyOverlay): { entries: TextEntry[]; conflicts: ConflictEntry[] };
```

`readOverlay`: Read `prototypes/[id]/copy-overlay.json`. If file doesn't exist, return `{ version: 1, entries: {} }`.

`patchOverlay`: Read existing overlay. Create or update `entries[key]`: set `editedValue: value`, `editedAt: new Date().toISOString()`, `sourceValueAtEdit: sourceValue`, and push `{ value, timestamp: new Date().toISOString() }` to the `edits` array (initialize as `[]` if new entry). Write back.

`mergeOverlayIntoEntries`: For each TextEntry, if overlay has matching key:
- If `overlay.entries[key].sourceValueAtEdit === entry.sourceValue`, apply edit: set `entry.currentValue = overlay.entries[key].editedValue`
- If `sourceValueAtEdit !== entry.sourceValue` AND `editedValue !== entry.sourceValue`, flag as conflict

```typescript
export interface ConflictEntry {
  key: string;
  designerValue: string;   // new source value
  copywriterValue: string; // edited value from overlay
}
```

Use `protoDir` pattern consistent with other routes. Use `fs.readFile` / `fs.writeFile` from `node:fs/promises`.

**3. Create `src/app/api/preview/[id]/screens/route.ts`**

`GET` handler that discovers screen files by scanning the prototype directory:
- Read directory contents with `fs.readdir`
- Find files matching pattern: `index.jsx` (always included as the default screen with id `"index"`) and `screen-*.jsx` files (id = the part after `screen-` before `.jsx`)
- Read `metadata.json` for custom names and order: `metadata.screens?.customNames` and `metadata.screens?.order`
- Return JSON array: `[{ id: string, name: string, file: string }]`
  - `name` = `customNames[id]` if exists, else capitalize the id (e.g., "login" -> "Login", "index" -> "Main")
  - Sort by `metadata.screens.order` if present, else alphabetical with "index" always first

Set `export const dynamic = 'force-dynamic';`.

**4. Extend `src/app/api/preview/[id]/bundle/route.ts`**

Add `?screen=` query param support:
- Read `searchParams.get('screen')` from the request URL
- If `screen` param is present and not `'index'`, build file path as `screen-${screen}.jsx` instead of `index.jsx`
- If no `screen` param or `screen === 'index'`, use `index.jsx` (existing behavior)
- Everything else stays the same

**5. Extend `src/app/api/preview/[id]/tree/route.ts`**

Same `?screen=` query param extension as bundle route — use `screen-${screen}.jsx` if screen param provided and not `'index'`.

**6. Create `src/app/api/preview/[id]/copy/route.ts`**

Two handlers:
- `GET`: Extract text entries from the active screen's source (accept `?screen=` param, default to `index`). Call `getPrototypeSource` then `extractTextEntries`. Read overlay via `readOverlay`. Merge with `mergeOverlayIntoEntries`. For each entry, attach the `edits` array from the overlay (empty array if no overlay entry). Return `{ entries: Array<TextEntry & { edits: EditHistoryEntry[] }>, conflicts: ConflictEntry[], summary: { total: number, modified: number } }`.
- `PATCH`: Accept `{ key: string, value: string, sourceValue: string }`. Call `patchOverlay`. Return `{ ok: true }`.

Set `export const dynamic = 'force-dynamic';`.

**7. Extend `src/stores/inspector.ts`**

Add screen-related state to the Zustand store:
```typescript
// Add to InspectorState:
activeScreenId: string;    // default: 'index'
screens: { id: string; name: string; file: string }[];

// Add to InspectorActions:
setActiveScreen: (id: string) => void;
setScreens: (screens: { id: string; name: string; file: string }[]) => void;
```

Add defaults: `activeScreenId: 'index'`, `screens: []`.
Add actions: `setActiveScreen: (id) => set({ activeScreenId: id })`, `setScreens: (screens) => set({ screens })`.
  </action>
  <verify>
    <automated>cd /Users/gyorgybokros/Projects/mq-ds-collab-tool && npx tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>
    - GET /api/preview/[id]/screens returns array of discovered screen files
    - GET /api/preview/[id]/bundle?screen=login serves screen-login.jsx bundle
    - GET /api/preview/[id]/tree?screen=login serves screen-login.jsx tree
    - GET /api/preview/[id]/copy returns text entries extracted from source with overlay merge
    - PATCH /api/preview/[id]/copy persists a text edit to copy-overlay.json
    - text-extractor.ts extracts text from JSXAttribute StringLiterals and JSXText children
    - copy-overlay.ts handles read/write/merge with conflict detection
    - Inspector store has activeScreenId and screens state
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no errors
- `curl http://localhost:3000/api/preview/sample/status` returns `{"status":"draft"}`
- `curl -X PATCH http://localhost:3000/api/preview/sample/status -H 'Content-Type: application/json' -d '{"status":"review"}'` returns `{"status":"review"}`
- `curl http://localhost:3000/api/preview/sample/screens` returns array with at least `[{"id":"index","name":"Main","file":"index.jsx"}]`
- `curl http://localhost:3000/api/preview/sample/copy` returns text entries from sample prototype
- Status badge visible in toolbar, clicking opens menu with three options
</verification>

<success_criteria>
1. Status badge shows colored Chip (grey=Draft, amber=Review, green=Approved) in toolbar, click changes status via API
2. Screen discovery returns all `screen-*.jsx` files plus `index.jsx`
3. Bundle and tree routes serve the correct screen when `?screen=` param is provided
4. Text extraction finds all string literals in text-bearing props (children, label, placeholder, aria-label, helperText, title) plus JSXText children
5. Copy overlay persistence: edits saved to copy-overlay.json, merged on next GET, conflicts detected when source changes under an edit
</success_criteria>

<output>
After completion, create `.planning/phases/03-copywriter-multi-screen-status/03-01-SUMMARY.md`
</output>
