---
phase: 03-copywriter-multi-screen-status
plan: 03
type: execute
wave: 2
depends_on: [03-01]
files_modified:
  - src/components/CopyTab.tsx
  - src/components/InspectorPanel.tsx
  - src/lib/postmessage-types.ts
  - public/preview-bootstrap.js
  - src/components/PreviewFrame.tsx
  - src/stores/copy.ts
autonomous: true
requirements: [INSP-03]

must_haves:
  truths:
    - "Copy tab shows all text strings from the prototype grouped by component"
    - "Editing a text field updates the preview live as you type"
    - "Text edits persist to copy-overlay.json and survive page reload"
    - "Clicking text in preview scrolls to and highlights the entry in Copy tab"
    - "Selecting an entry in Copy tab highlights the element in preview"
    - "Modified entries show a colored indicator and can be reset to source value"
    - "Export downloads all text entries as JSON, import uploads them back"
    - "Conflicts shown when designer and copywriter both changed the same text"
  artifacts:
    - path: "src/components/CopyTab.tsx"
      provides: "Full copy editor UI with search, groups, editing, export/import"
      exports: ["CopyTab"]
      min_lines: 100
    - path: "src/stores/copy.ts"
      provides: "Zustand store for copy tab state"
      exports: ["useCopyStore"]
    - path: "public/preview-bootstrap.js"
      provides: "SET_TEXT_OVERRIDES and TEXT_CLICK message handling in iframe"
      min_lines: 350
  key_links:
    - from: "src/components/CopyTab.tsx"
      to: "/api/preview/[id]/copy"
      via: "fetch GET on mount, PATCH on edit"
      pattern: "fetch.*copy"
    - from: "src/components/CopyTab.tsx"
      to: "public/preview-bootstrap.js"
      via: "SET_TEXT_OVERRIDES postMessage on edit"
      pattern: "SET_TEXT_OVERRIDES"
    - from: "public/preview-bootstrap.js"
      to: "src/components/CopyTab.tsx"
      via: "TEXT_CLICK postMessage on text click in preview"
      pattern: "TEXT_CLICK"
---

<objective>
Build the Copy tab — the full copy editing experience where copywriters see all prototype text strings, edit them inline with live preview updates, and manage text through export/import. Includes two-way visual linking between Copy tab entries and preview elements.

Purpose: Fulfills INSP-03 — copywriters can edit all prototype text without touching code, see changes live, export/import for offline editing, and resolve conflicts when source changes.

Output: CopyTab component replacing the placeholder, copy Zustand store, extended postMessage protocol for text overrides, iframe bootstrap with text injection support.
</objective>

<execution_context>
@/Users/gyorgybokros/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gyorgybokros/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-copywriter-multi-screen-status/03-RESEARCH.md
@.planning/phases/03-copywriter-multi-screen-status/03-01-SUMMARY.md

@src/components/InspectorPanel.tsx
@src/lib/postmessage-types.ts
@public/preview-bootstrap.js
@src/components/PreviewFrame.tsx
@src/stores/inspector.ts

<interfaces>
<!-- From 03-01: text extraction types -->
From src/lib/text-extractor.ts:
```typescript
export interface TextEntry {
  key: string;             // "ComponentName_line_col_propName"
  componentName: string;
  componentPath: string;   // "AppBar > Toolbar > Typography"
  propName: string;
  category: 'visible' | 'placeholder' | 'accessibility';
  sourceValue: string;
  currentValue: string;
  sourceLine: number;
  inspectorId: string;     // "ComponentName_line_col"
}
```

<!-- From 03-01: copy overlay types -->
From src/lib/copy-overlay.ts:
```typescript
export interface ConflictEntry {
  key: string;
  designerValue: string;
  copywriterValue: string;
}
```

<!-- From 03-01: copy API response -->
```typescript
// GET /api/preview/[id]/copy?screen=index
{
  entries: TextEntry[],
  conflicts: ConflictEntry[],
  summary: { total: number, modified: number }
}

// PATCH /api/preview/[id]/copy
{ key: string, value: string, sourceValue: string }
```

<!-- From existing postmessage-types.ts -->
From src/lib/postmessage-types.ts:
```typescript
export type ShellToIframe =
  | { type: 'SET_THEME'; mode: 'light' | 'dark' | 'system' }
  | { type: 'RELOAD' }
  | { type: 'SET_INSPECTOR_MODE'; enabled: boolean };

export type IframeToShell =
  | { type: 'RENDER_ERROR'; message: string }
  | { type: 'COMPONENT_TREE'; tree: ComponentNode[] }
  | { type: 'COMPONENT_HOVER'; id: string | null; rect: ... }
  | { type: 'COMPONENT_SELECT'; id: string; rect: ... };
```

<!-- From existing InspectorPanel.tsx -->
The Copy tab placeholder is in TabPanel index 0:
```tsx
<TabPanel value={tabIndex} index={0}>
  <Box sx={{ p: 2 }}>
    <Typography variant="body2" color="text.secondary">
      Copy editing will be available in a future update.
    </Typography>
  </Box>
</TabPanel>
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Copy Zustand store, postMessage protocol extension, and iframe text injection</name>
  <files>
    src/stores/copy.ts
    src/lib/postmessage-types.ts
    public/preview-bootstrap.js
  </files>
  <action>
**1. Create `src/stores/copy.ts`**

Zustand store managing copy tab state:

```typescript
import { create } from 'zustand';
import type { TextEntry } from '@/lib/text-extractor';
import type { ConflictEntry } from '@/lib/copy-overlay';

interface CopyEntryWithHistory extends TextEntry {
  edits: Array<{ value: string; timestamp: string }>;  // edit history from overlay
}

interface CopyState {
  entries: CopyEntryWithHistory[];
  conflicts: ConflictEntry[];
  summary: { total: number; modified: number };
  searchQuery: string;
  collapsedGroups: Set<string>;   // component names that are collapsed
  highlightedKey: string | null;  // entry highlighted from preview click
  loading: boolean;
}

interface CopyActions {
  setEntries: (entries: TextEntry[], conflicts: ConflictEntry[], summary: { total: number; modified: number }) => void;
  updateEntry: (key: string, value: string) => void;
  resetEntry: (key: string) => void;
  setSearchQuery: (query: string) => void;
  toggleGroup: (componentName: string) => void;
  setHighlightedKey: (key: string | null) => void;
  setLoading: (loading: boolean) => void;
  resolveConflict: (key: string, chosenValue: string) => void;
}
```

`updateEntry`: Find entry by key, set `currentValue` to new value. Do NOT update `sourceValue`. Increment modified count in summary.

`resetEntry`: Find entry by key, set `currentValue = sourceValue`. Decrement modified count.

`resolveConflict`: Remove from conflicts array, update entry's currentValue to chosenValue.

`collapsedGroups` uses a `Set<string>` — persisted state not needed here (ephemeral is fine; CONTEXT.md says "persisted collapsed/expanded state across sessions" but for v1 simplicity, use localStorage in the component, not the store).

**2. Extend `src/lib/postmessage-types.ts`**

Add Phase 3 message types:

```typescript
// Shell -> iframe (add to ShellToIframe union):
| { type: 'SET_TEXT_OVERRIDES'; overrides: Record<string, Record<string, string>> }
// overrides format: { [inspectorId]: { [propName]: editedValue } }
// e.g., { "Typography_5_4": { "children": "New text" } }

| { type: 'HIGHLIGHT_TEXT'; inspectorId: string | null }
// Highlights an element in the preview when an entry is selected in Copy tab

// Iframe -> shell (add to IframeToShell union):
| { type: 'TEXT_CLICK'; key: string; inspectorId: string }
// Sent when user clicks text in the preview while Copy tab is active
```

**3. Extend `public/preview-bootstrap.js`**

Add three features to the iframe bootstrap:

**a) Text override state and application:**

In the `Root` component, add a `textOverrides` state:
```javascript
const [textOverrides, setTextOverrides] = useState({});
// overrides: Record<inspectorId, Record<propName, string>>
```

Listen for `SET_TEXT_OVERRIDES` postMessage:
```javascript
if (event.data?.type === 'SET_TEXT_OVERRIDES') {
  setTextOverrides(event.data.overrides);
}
```

Pass `textOverrides` down through `PreviewApp` to the prototype component via a React context:
```javascript
// Create context at module level
const TextOverrideContext = React.createContext({});
```

Wrap the prototype Component in a `TextOverrideContext.Provider` so the override application layer can access it.

**Text application approach:** After the prototype renders, use a `useEffect` in a `TextOverrideApplier` component that:
- Runs after each render (and when `textOverrides` change)
- Finds all elements with `data-inspector-id` attribute
- For each element whose `inspectorId` has overrides:
  - For `children` prop: find the first text node child and update its `nodeValue`
  - For attribute props (label, placeholder, aria-label, etc.): find the corresponding rendered input/element and update the attribute or property
- **IMPORTANT per RESEARCH pitfall 3:** Direct DOM mutation will be overwritten by React on re-render. To handle this: use `MutationObserver` or re-apply overrides on every React update. Simpler approach: use `requestAnimationFrame` loop that checks and re-applies overrides continuously while overrides are active. This is the pragmatic approach — the override map is small (typically <50 entries), and RAF is cheap.

Actually, the RESEARCH recommends: "The iframe must maintain a React state map of overrides and update text nodes through React state." But modifying the prototype's React component is not feasible since it's user-generated code.

**Pragmatic approach:** Use a `MutationObserver` + initial application. After each DOM mutation, re-scan `data-inspector-id` elements and apply overrides. This handles React re-renders that would overwrite DOM changes.

```javascript
function TextOverrideApplier() {
  const overrides = useContext(TextOverrideContext);

  useEffect(() => {
    function applyOverrides() {
      for (const [inspectorId, propOverrides] of Object.entries(overrides)) {
        const el = document.querySelector(`[data-inspector-id="${inspectorId}"]`);
        if (!el) continue;
        for (const [propName, value] of Object.entries(propOverrides)) {
          if (propName === 'children') {
            // Find first text node and update
            const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null);
            const textNode = walker.nextNode();
            if (textNode && textNode.nodeValue?.trim()) {
              textNode.nodeValue = value;
            }
          } else if (propName === 'placeholder') {
            const input = el.querySelector('input, textarea') || el;
            if (input) input.setAttribute('placeholder', value);
          } else if (propName === 'aria-label') {
            el.setAttribute('aria-label', value);
          } else if (propName === 'label') {
            // MUI label is rendered as a <label> child
            const label = el.querySelector('label');
            if (label) label.textContent = value;
          }
          // helperText, title — similar patterns
        }
      }
    }

    applyOverrides();

    // Re-apply after React re-renders
    const observer = new MutationObserver(() => {
      requestAnimationFrame(applyOverrides);
    });
    observer.observe(document.getElementById('root'), { childList: true, subtree: true, characterData: true });

    return () => observer.disconnect();
  }, [overrides]);

  return null;
}
```

**b) Text click handler:**

When the Copy tab is active, clicking text in the preview should notify the shell. Extend the existing click handler (inspector mode click):

Add a separate listener (don't modify the inspector click handler): When `SET_TEXT_OVERRIDES` has been received (meaning Copy tab is active), clicking an element with `data-inspector-id` sends `TEXT_CLICK`:
```javascript
// Track if copy mode is active
let copyModeActive = false;
window.addEventListener('message', (e) => {
  if (e.data?.type === 'SET_TEXT_OVERRIDES') copyModeActive = true;
  if (e.data?.type === 'SET_INSPECTOR_MODE') copyModeActive = false; // copy mode off when inspector mode on
});

// In the existing click handler, if copyModeActive:
// Send TEXT_CLICK with the inspectorId and construct the text entry key
```

Actually, simpler: always send `TEXT_CLICK` alongside `COMPONENT_SELECT` when a text element is clicked. The shell decides what to do based on which tab is active. Add to the existing click handler:

```javascript
// After sending COMPONENT_SELECT, also determine text key:
const inspectorId = target.dataset.inspectorId;
// The shell needs to match inspectorId to a text entry key — the shell does this matching
window.parent.postMessage({ type: 'TEXT_CLICK', key: '', inspectorId }, '*');
```

**c) Highlight element:**

Listen for `HIGHLIGHT_TEXT` postMessage — highlight the element with the matching `data-inspector-id` using the existing overlay mechanism:
```javascript
if (event.data?.type === 'HIGHLIGHT_TEXT') {
  const id = event.data.inspectorId;
  if (id) {
    const el = document.querySelector(`[data-inspector-id="${id}"]`);
    if (el) {
      const rect = el.getBoundingClientRect();
      const overlay = ensureOverlay();
      overlay.style.top = rect.top + 'px';
      overlay.style.left = rect.left + 'px';
      overlay.style.width = rect.width + 'px';
      overlay.style.height = rect.height + 'px';
      overlay.style.display = 'block';
      overlay.style.borderColor = '#ed6c02'; // warning/amber to distinguish from inspector blue
    }
  } else {
    const overlay = ensureOverlay();
    overlay.style.display = 'none';
    overlay.style.borderColor = '#1976d2'; // restore default
  }
}
```
  </action>
  <verify>
    <automated>cd /Users/gyorgybokros/Projects/mq-ds-collab-tool && npx tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>
    - Copy Zustand store manages entries, conflicts, search, collapsed groups, and highlighted key
    - postmessage-types.ts has SET_TEXT_OVERRIDES, HIGHLIGHT_TEXT, and TEXT_CLICK types
    - preview-bootstrap.js handles SET_TEXT_OVERRIDES with MutationObserver-based DOM override application
    - preview-bootstrap.js sends TEXT_CLICK when text is clicked in preview
    - preview-bootstrap.js highlights elements on HIGHLIGHT_TEXT message
  </done>
</task>

<task type="auto">
  <name>Task 2: CopyTab component and InspectorPanel integration</name>
  <files>
    src/components/CopyTab.tsx
    src/components/InspectorPanel.tsx
    src/components/PreviewFrame.tsx
  </files>
  <action>
**1. Create `src/components/CopyTab.tsx`** — `'use client'` component.

Props: `{ prototypeId: string }`.

**Top section — summary header + search + actions:**
- Summary: `Typography` showing "N text entries · M modified" (from store summary)
- Search: MUI `TextField` (size="small", variant="outlined") with search icon InputAdornment. On change, call `setSearchQuery(value)` on the copy store
- Action buttons row: Export JSON button (DownloadIcon), Import JSON button (UploadIcon)

**Main section — grouped text entries:**

Group entries by `componentName`. For each group:
- **Group header:** Collapsible `Box` with component name, entry count badge, expand/collapse icon (ExpandMore/ExpandLess). Click toggles group in store `toggleGroup(componentName)`
- **Breadcrumb tooltip:** On hover over group header, show `Tooltip` with full `componentPath` from the first entry in the group

Within each group, entries are sub-grouped by category with subtle category labels: "Visible Text", "Placeholder", "Accessibility".

**Each text entry row:**
- **Label:** `Typography` variant="caption" showing `propName` (e.g., "children", "label", "placeholder")
- **Input field:**
  - If `sourceValue` contains `\n` or length > 80: MUI `TextField` with `multiline`, `minRows={1}`, `maxRows={6}`
  - Otherwise: MUI `TextField` single-line
  - `size="small"`, `fullWidth`
  - Value: `entry.currentValue`
  - On change:
    1. Update store via `updateEntry(entry.key, newValue)`
    2. Debounce PATCH to `/api/preview/${prototypeId}/copy` with `{ key: entry.key, value: newValue, sourceValue: entry.sourceValue }` — use a 500ms debounce to avoid hammering the API
    3. Send `SET_TEXT_OVERRIDES` postMessage to iframe with ALL current overrides (build the full override map from entries where `currentValue !== sourceValue`)
- **Character count:** `helperText` on the TextField showing `${value.length} chars`
- **Modified indicator:** Small colored dot (MUI `Badge` or colored `Box` with `width: 8, height: 8, borderRadius: '50%'`) next to label when `currentValue !== sourceValue`
- **Reset button:** Small `IconButton` (RestoreIcon or UndoIcon) visible only when modified. Clicks `resetEntry(key)` and sends updated `SET_TEXT_OVERRIDES` to iframe
- **Edit history log** (per CONTEXT.md locked decision "Simple edit history log per entry"): For modified entries, show a small `HistoryIcon` button next to the reset button. On click, toggle an expandable section (`Collapse` component) below the input that lists the entry's edit history from the overlay: original value at the top (labelled "Original"), then each edit with its timestamp (formatted as relative time, e.g., "2 min ago"). Fetch history from the copy API — extend `GET /api/preview/${prototypeId}/copy` response to include `edits` array per entry from the overlay. Store the edits array in the copy store entries. The expandable section uses a `List` with `ListItemText` for each history entry showing the value and timestamp.

**Filtering:** When `searchQuery` is non-empty, filter entries where `currentValue`, `sourceValue`, `componentName`, or `componentPath` contains the query (case-insensitive). Hide empty groups.

**Two-way visual linking:**

- **Preview -> Copy tab (click-to-select):** Listen for `TEXT_CLICK` postMessage from iframe (in PreviewFrame component or in CopyTab via a message listener). On TEXT_CLICK, find the matching entry by `inspectorId`, call `setHighlightedKey(entry.key)`, and scroll the entry into view using a `ref` + `scrollIntoView({ behavior: 'smooth', block: 'center' })`.
- **Copy tab -> Preview (reverse highlight):** When user focuses/clicks an entry's TextField, send `HIGHLIGHT_TEXT { inspectorId: entry.inspectorId }` to iframe. On blur, send `HIGHLIGHT_TEXT { inspectorId: null }`.

**Conflict display:**
When `conflicts.length > 0`, show a warning banner at the top of the Copy tab: "N text entries have conflicts — designer changed the source text after you edited it."

For each conflicted entry, show side-by-side in the entry row:
- Left: "Designer's version: {designerValue}" with an "Accept" button
- Right: "Your version: {copywriterValue}" with a "Keep" button
- Clicking either calls `resolveConflict(key, chosenValue)` and updates the overlay via PATCH

**Export/Import:**

Export button: Collect all entries, format as JSON with structure:
```json
{
  "prototypeId": "sample",
  "exportedAt": "...",
  "entries": [{ "key": "...", "componentName": "...", "propName": "...", "value": "..." }]
}
```
Create a Blob, create an object URL, trigger download via a hidden `<a>` element.

Import button: Hidden `<input type="file" accept=".json">` triggered by the button click. On file select, read JSON, match entries by `key`, update store and send PATCH for each matched entry. Show a toast or inline message: "Imported N entries, M skipped (not found in current source)."

**Friendly empty state:**
If `entries.length === 0` and not loading, show a centered message: "No text entries found in this prototype. Add Typography, Button, or other text components to see them here."

**On mount:**
- Fetch `GET /api/preview/${prototypeId}/copy?screen=${activeScreenId}` (get activeScreenId from inspector store)
- Populate copy store via `setEntries()`
- If any entries have `currentValue !== sourceValue`, build override map and send `SET_TEXT_OVERRIDES` to iframe

**On screen change:**
- Watch `activeScreenId` from inspector store — refetch copy data when screen changes

**2. Update `src/components/InspectorPanel.tsx`**

Replace the Copy tab placeholder:
```tsx
// Before:
<TabPanel value={tabIndex} index={0}>
  <Box sx={{ p: 2 }}>
    <Typography variant="body2" color="text.secondary">
      Copy editing will be available in a future update.
    </Typography>
  </Box>
</TabPanel>

// After:
<TabPanel value={tabIndex} index={0}>
  <CopyTab prototypeId={prototypeId} />
</TabPanel>
```

Add `prototypeId` prop to InspectorPanel:
```typescript
interface InspectorPanelProps {
  prototypeId: string;
}
export function InspectorPanel({ prototypeId }: InspectorPanelProps) { ... }
```

Update `page.tsx` to pass `prototypeId` to InspectorPanel (if not already: `<InspectorPanel prototypeId={prototypeId} />`).

**3. Update `src/components/PreviewFrame.tsx`**

Add a `useEffect` listener for `TEXT_CLICK` messages from the iframe:
```typescript
useEffect(() => {
  function handleMessage(event: MessageEvent) {
    if (event.data?.type === 'TEXT_CLICK') {
      // Forward to copy store
      const { inspectorId } = event.data;
      // Find matching entry key from copy store entries
      const entries = useCopyStore.getState().entries;
      const match = entries.find(e => e.inspectorId === inspectorId);
      if (match) {
        useCopyStore.getState().setHighlightedKey(match.key);
      }
    }
  }
  window.addEventListener('message', handleMessage);
  return () => window.removeEventListener('message', handleMessage);
}, []);
```

Also, provide a ref to the iframe element so CopyTab can call `iframeRef.current.contentWindow.postMessage(...)` for SET_TEXT_OVERRIDES and HIGHLIGHT_TEXT. Alternatively, use a shared utility function or store the iframe ref in a module-level variable. Simplest approach: use `document.querySelector('iframe')` in the CopyTab to get the iframe reference. Not ideal but pragmatic for v1.

Better approach: Create a `useIframeRef` hook or store the iframe element in Zustand. Or simply: export a `postToPreview(message)` utility from PreviewFrame that finds the iframe and posts. Actually simplest: the iframe `name` or `id` can be set, then `CopyTab` can use `document.getElementById('preview-iframe')?.contentWindow?.postMessage(...)`.

Add `id="preview-iframe"` to the iframe element in PreviewFrame.
  </action>
  <verify>
    <automated>cd /Users/gyorgybokros/Projects/mq-ds-collab-tool && npx tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>
    - Copy tab shows all text entries grouped by component with category sub-groups
    - Search bar filters entries by content or component name
    - Editing a text field sends SET_TEXT_OVERRIDES to iframe for live preview update
    - Edits debounce-persist to copy-overlay.json via PATCH API
    - Modified entries show colored dot indicator and reset button
    - Character count shown below each field
    - Clicking text in preview highlights and scrolls to entry in Copy tab
    - Selecting entry in Copy tab highlights element in preview
    - Conflicts shown with designer/copywriter side-by-side and resolve buttons
    - Export downloads JSON, import uploads and matches by key
    - Empty state message when no text entries found
    - InspectorPanel Copy tab placeholder replaced with CopyTab component
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no errors
- Copy tab displays text entries from sample prototype
- Editing text in Copy tab updates the preview live (visible change in iframe)
- Text edits persist across page refresh (reload page, Copy tab shows edited values)
- Click text in preview → Copy tab scrolls to and highlights the entry
- Select entry in Copy tab → preview highlights the element with amber border
- Export button downloads JSON file with all text entries
- Import button loads JSON and updates matching entries
</verification>

<success_criteria>
1. All text strings from prototype visible in Copy tab, organized by component and category
2. Live-as-you-type preview updates via SET_TEXT_OVERRIDES postMessage
3. Edits persist to copy-overlay.json and restore correctly on reload
4. Two-way visual linking: preview click -> Copy tab scroll, Copy tab select -> preview highlight
5. Export/import workflow functional with key-based matching
6. Conflict detection and resolution UI when source changes under an edit
</success_criteria>

<output>
After completion, create `.planning/phases/03-copywriter-multi-screen-status/03-03-SUMMARY.md`
</output>
