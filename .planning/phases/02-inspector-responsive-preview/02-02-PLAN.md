---
phase: 02-inspector-responsive-preview
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/components/BreakpointSwitcher.tsx
  - src/components/Toolbar.tsx
  - src/components/PreviewFrame.tsx
  - src/app/(shell)/page.tsx
  - src/components/InspectorPanel.tsx
  - src/components/ComponentTree.tsx
  - src/components/PropInspector.tsx
autonomous: true
requirements:
  - REND-04
  - INSP-01
  - INSP-02
  - INSP-04

must_haves:
  truths:
    - "Selecting xs, sm, md, lg, or xl resizes the preview iframe to that exact pixel width"
    - "Auto mode makes the preview fill available space"
    - "When a fixed breakpoint is active, the iframe is centered with a gray surround"
    - "The Components tab shows the MUI component hierarchy as a tree"
    - "Clicking a component in the tree shows its props in a key-value table"
    - "Complex props (expression rawType) are expandable on click to show value in a distinct monospace block"
    - "The Copy tab placeholder is present and switching tabs preserves state"
    - "Hovering a component in the iframe highlights it and selects it in the tree"
    - "Clicking a component in the iframe selects it in the tree and shows its props"
    - "The inspector panel is collapsible"
  artifacts:
    - path: "src/components/BreakpointSwitcher.tsx"
      provides: "Toolbar breakpoint button group"
      exports: ["BreakpointSwitcher"]
    - path: "src/components/InspectorPanel.tsx"
      provides: "Right sidebar with Copy/Components tabs"
      exports: ["InspectorPanel"]
    - path: "src/components/ComponentTree.tsx"
      provides: "Recursive MUI component tree view"
      exports: ["ComponentTree"]
    - path: "src/components/PropInspector.tsx"
      provides: "Key-value prop table for selected component"
      exports: ["PropInspector"]
  key_links:
    - from: "src/app/(shell)/page.tsx"
      to: "src/components/InspectorPanel.tsx"
      via: "import and render alongside PreviewFrame"
      pattern: "InspectorPanel"
    - from: "src/components/InspectorPanel.tsx"
      to: "src/stores/inspector.ts"
      via: "useInspectorStore for activeTab, selectedComponentId, componentTree"
      pattern: "useInspectorStore"
    - from: "src/components/PreviewFrame.tsx"
      to: "src/stores/inspector.ts"
      via: "useInspectorStore for previewWidth, handling COMPONENT_HOVER/SELECT messages"
      pattern: "useInspectorStore"
    - from: "src/components/BreakpointSwitcher.tsx"
      to: "src/stores/inspector.ts"
      via: "useInspectorStore.setPreviewWidth"
      pattern: "setPreviewWidth"
---

<objective>
Build the responsive preview, inspector panel UI, component tree, and prop inspector.

Purpose: Wire the AST data from Plan 01 into interactive UI — the breakpoint switcher controls iframe width, the inspector panel displays the component tree with prop details, and hover/click in the iframe syncs with the panel. This completes all four Phase 2 requirements.

Output: BreakpointSwitcher in toolbar, responsive PreviewFrame, InspectorPanel with tabs (Copy placeholder + Components), ComponentTree, PropInspector, hover/click overlay wiring.
</objective>

<execution_context>
@/Users/gyorgybokros/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gyorgybokros/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-inspector-responsive-preview/02-RESEARCH.md
@.planning/phases/02-inspector-responsive-preview/02-01-SUMMARY.md

@src/components/Toolbar.tsx
@src/components/PreviewFrame.tsx
@src/app/(shell)/page.tsx

<interfaces>
<!-- From Plan 02-01 outputs -->

From src/lib/ast-inspector.ts:
```typescript
export interface PropEntry {
  name: string;
  value: string;     // serialized display value
  rawType: string;   // 'string' | 'number' | 'boolean' | 'expression' | 'spread'
}

export interface ComponentNode {
  id: string;          // "Button_3_12" (name_line_col)
  componentName: string;
  props: PropEntry[];
  sourceFile: string;
  sourceLine: number;
  children: ComponentNode[];
}

export function extractComponentTree(sourceCode: string, filePath: string): ComponentNode[];
```

From src/stores/inspector.ts:
```typescript
export const useInspectorStore: UseBoundStore<StoreApi<InspectorState & InspectorActions>>;

interface InspectorState {
  panelOpen: boolean;
  activeTab: 'copy' | 'components';
  selectedComponentId: string | null;
  hoveredComponentId: string | null;
  componentTree: ComponentNode[];
  inspectorMode: boolean;
  previewWidth: number | 'auto';
}

interface InspectorActions {
  togglePanel: () => void;
  setActiveTab: (tab: 'copy' | 'components') => void;
  setSelectedComponent: (id: string | null) => void;
  setHoveredComponent: (id: string | null) => void;
  setComponentTree: (tree: ComponentNode[]) => void;
  setPreviewWidth: (width: number | 'auto') => void;
  setInspectorMode: (enabled: boolean) => void;
}
```

From src/lib/postmessage-types.ts:
```typescript
export type ShellToIframe =
  | { type: 'SET_THEME'; mode: 'light' | 'dark' | 'system' }
  | { type: 'RELOAD' }
  | { type: 'SET_INSPECTOR_MODE'; enabled: boolean };

export type IframeToShell =
  | { type: 'RENDER_ERROR'; message: string }
  | { type: 'COMPONENT_TREE'; tree: ComponentNode[] }
  | { type: 'COMPONENT_HOVER'; id: string | null; rect: { ... } | null }
  | { type: 'COMPONENT_SELECT'; id: string; rect: { ... } };
```

From src/components/Toolbar.tsx:
```typescript
interface ToolbarProps {
  prototypeName: string;
}
export function Toolbar({ prototypeName }: ToolbarProps): JSX.Element;
// Contains AppBar with MuiToolbar variant="dense", prototype name left, theme toggle right
```

From src/components/PreviewFrame.tsx:
```typescript
interface PreviewFrameProps {
  prototypeId: string;
}
export function PreviewFrame({ prototypeId }: PreviewFrameProps): JSX.Element;
// Contains iframe with src=/preview/{id}, postMessage bridge, SSE hot reload
// Outer Box has flex:1, contains loading spinner, error display, iframe
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Breakpoint switcher + responsive PreviewFrame + shell layout with panel</name>
  <files>
    src/components/BreakpointSwitcher.tsx
    src/components/Toolbar.tsx
    src/components/PreviewFrame.tsx
    src/app/(shell)/page.tsx
  </files>
  <action>
**1. Create `src/components/BreakpointSwitcher.tsx`**

A button group for the toolbar showing breakpoint options. Per CONTEXT.md locked decisions:
- Labels: "Auto", "xs (360)", "sm (600)", "md (900)", "lg (1200)", "xl (1536)"
- Default is "Auto" (preview fills available space)

```tsx
const BREAKPOINTS = [
  { label: 'Auto', width: 'auto' as const },
  { label: 'xs (360)', width: 360 },
  { label: 'sm (600)', width: 600 },
  { label: 'md (900)', width: 900 },
  { label: 'lg (1200)', width: 1200 },
  { label: 'xl (1536)', width: 1536 },
] as const;
```

Use MUI `ButtonGroup` with `size="small"` and `variant="outlined"`. Active breakpoint uses `variant="contained"`. Read `previewWidth` and `setPreviewWidth` from `useInspectorStore`.

**2. Modify `src/components/Toolbar.tsx`**

Add `BreakpointSwitcher` to the toolbar. Place it between the prototype name and the theme toggle (in the center area). Import `BreakpointSwitcher` component. Also add a panel toggle button (per CONTEXT.md: collapsible panel with toggle button).

Layout change: prototype name (left) → flex spacer → BreakpointSwitcher (center) → panel toggle icon button → theme toggle (right).

The panel toggle button uses a sidebar icon (`ViewSidebar` from `@mui/icons-material`) and calls `useInspectorStore().togglePanel()`.

**3. Modify `src/components/PreviewFrame.tsx`**

Add responsive width support driven by the Zustand store:
- Import `useInspectorStore` and read `previewWidth`, `setHoveredComponent`, `setSelectedComponent`, `setComponentTree`.
- Change the outer Box to be a preview AREA container with gray background when a fixed breakpoint is active.
- Inside the area, a width-constrained wrapper centers the iframe:

```tsx
// Preview area — gray surround when fixed width
<Box sx={{
  flex: 1,
  display: 'flex',
  alignItems: 'stretch',
  justifyContent: 'center',
  overflow: 'auto',
  bgcolor: previewWidth === 'auto' ? 'transparent' : 'grey.100',
  position: 'relative',
}}>
  {/* Width-constrained wrapper */}
  <Box sx={{
    width: previewWidth === 'auto' ? '100%' : previewWidth,
    maxWidth: '100%',
    flexShrink: 0,
    position: 'relative',
    display: 'flex',
    flexDirection: 'column',
    bgcolor: 'background.default',  // white/dark inside the bounds
  }}>
    {/* Loading spinner, error display, iframe — existing content */}
  </Box>
</Box>
```

CRITICAL (from research): The iframe must be ACTUALLY resized by setting the container's pixel width. Do NOT use CSS `transform: scale()`.

Also add postMessage listener for `COMPONENT_HOVER` and `COMPONENT_SELECT` from the iframe. In the existing `handleMessage` function, add cases:

```typescript
if (event.data.type === 'COMPONENT_HOVER') {
  setHoveredComponent(event.data.id);
}
if (event.data.type === 'COMPONENT_SELECT') {
  setSelectedComponent(event.data.id);
}
```

Also fetch the component tree from `/api/preview/[id]/tree` on mount and on reload (after SSE file change). Store in `setComponentTree`. Add this as an async call:

```typescript
async function fetchTree() {
  try {
    const res = await fetch(`/api/preview/${prototypeId}/tree`);
    if (res.ok) {
      const tree = await res.json();
      setComponentTree(tree);
    }
  } catch { /* ignore tree fetch errors */ }
}
```

Call `fetchTree()` in the initial mount effect and after each SSE-triggered reload.

**4. Modify `src/app/(shell)/page.tsx`**

Change layout from vertical (toolbar + preview) to include the inspector panel on the right:

```tsx
import { InspectorPanel } from '@/components/InspectorPanel';

export default function ShellPage() {
  return (
    <Box sx={{ height: '100vh', display: 'flex', flexDirection: 'column', overflow: 'hidden' }}>
      <Toolbar prototypeName={prototypeId} />
      <Box sx={{ flex: 1, display: 'flex', overflow: 'hidden' }}>
        <PreviewFrame prototypeId={prototypeId} />
        <InspectorPanel prototypeId={prototypeId} />
      </Box>
    </Box>
  );
}
```

The `InspectorPanel` sits to the right of `PreviewFrame`. Both are inside a flex row. `PreviewFrame` has `flex: 1`, `InspectorPanel` has a fixed width (320px per Claude's discretion, matching VS Code default sidebar).
  </action>
  <verify>
    <automated>cd /Users/gyorgybokros/Projects/mq-ds-collab-tool && npx tsc --noEmit 2>&1 | tail -20 && echo "TSC OK" || echo "TSC ERRORS"</automated>
  </verify>
  <done>
    - BreakpointSwitcher renders 6 buttons (Auto + 5 MUI breakpoints) in the toolbar
    - Clicking a breakpoint button sets `previewWidth` in Zustand store
    - PreviewFrame width responds to store changes — auto fills space, fixed widths center with gray surround
    - Shell page layout has toolbar on top, preview on left, inspector panel on right
    - PreviewFrame handles COMPONENT_HOVER/SELECT postMessages and updates Zustand
    - Component tree is fetched from /api/preview/[id]/tree on mount and reload
  </done>
</task>

<task type="auto">
  <name>Task 2: Inspector panel with tabs, component tree, and prop inspector</name>
  <files>
    src/components/InspectorPanel.tsx
    src/components/ComponentTree.tsx
    src/components/PropInspector.tsx
  </files>
  <action>
**1. Create `src/components/ComponentTree.tsx`**

A recursive tree view of MUI components, styled like Chrome DevTools Elements panel (per CONTEXT.md specific ideas).

Props interface:
```typescript
interface ComponentTreeProps {
  tree: ComponentNode[];
  selectedId: string | null;
  hoveredId: string | null;
  onSelect: (id: string) => void;
  onHover: (id: string | null) => void;
}
```

Implementation:
- Render as a recursive list. Each node shows: expand/collapse arrow (if has children), component name in a monospace font.
- Component name styled as a tag: `<ComponentName>` in blue/teal color (similar to DevTools element highlighting).
- Indentation via `paddingLeft` per nesting level (16px per level).
- Selected node has a highlighted background (`action.selected` MUI theme color).
- Hovered node (from iframe hover) has a subtle highlight (`action.hover`).
- Clicking a node calls `onSelect(node.id)`.
- Mouse enter on a node calls `onHover(node.id)`, mouse leave calls `onHover(null)`.
- Use MUI `Collapse` for expand/collapse animation, or simple `display:none` toggle for performance.
- All nodes start expanded by default (typical for small-medium component trees).
- When `selectedId` changes (from iframe click), auto-expand the path to that node and scroll it into view. Use a `useEffect` that watches `selectedId` and walks the tree to find the path, expanding all ancestors. Use `scrollIntoView({ block: 'nearest' })` on the selected node ref.

Tree node rendering (recursive):
```tsx
function TreeNode({ node, level, selectedId, hoveredId, onSelect, onHover, expandedSet, toggleExpand }) {
  const isSelected = selectedId === node.id;
  const isHovered = hoveredId === node.id;
  const isExpanded = expandedSet.has(node.id);
  const hasChildren = node.children.length > 0;
  const nodeRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (isSelected && nodeRef.current) {
      nodeRef.current.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
    }
  }, [isSelected]);

  return (
    <>
      <Box ref={nodeRef} onClick={() => onSelect(node.id)} onMouseEnter={() => onHover(node.id)} onMouseLeave={() => onHover(null)}
        sx={{
          pl: level * 2,
          py: 0.25,
          cursor: 'pointer',
          bgcolor: isSelected ? 'action.selected' : isHovered ? 'action.hover' : 'transparent',
          '&:hover': { bgcolor: isSelected ? 'action.selected' : 'action.hover' },
          display: 'flex',
          alignItems: 'center',
          fontFamily: 'monospace',
          fontSize: '13px',
          userSelect: 'none',
        }}>
        {/* Expand/collapse icon */}
        <Box sx={{ width: 16, flexShrink: 0 }} onClick={(e) => { e.stopPropagation(); if (hasChildren) toggleExpand(node.id); }}>
          {hasChildren ? (isExpanded ? '▼' : '▶') : ''}
        </Box>
        {/* Component name as tag */}
        <Typography component="span" sx={{ fontFamily: 'monospace', fontSize: '13px', color: 'primary.main' }}>
          {'<'}{node.componentName}{node.props.length > 0 ? ' ...' : ''}{hasChildren ? '>' : ' />'}
        </Typography>
      </Box>
      {hasChildren && isExpanded && node.children.map((child) => (
        <TreeNode key={child.id} node={child} level={level + 1} ... />
      ))}
    </>
  );
}
```

The `ComponentTree` wrapper manages the `expandedSet` state (a `Set<string>`). Initialize with all node IDs expanded. When `selectedId` changes from outside (iframe click), compute the path to the selected node, ensure all ancestors are expanded.

Path computation helper:
```typescript
function findPathToNode(tree: ComponentNode[], targetId: string): string[] | null {
  for (const node of tree) {
    if (node.id === targetId) return [node.id];
    const childPath = findPathToNode(node.children, targetId);
    if (childPath) return [node.id, ...childPath];
  }
  return null;
}
```

**2. Create `src/components/PropInspector.tsx`**

A key-value table showing props for the selected component. Per CONTEXT.md locked decisions:
- Two columns: prop name | value
- Complex props shown as inline summary, expandable on click
- Read-only
- Shows source file location (file path + line number)

Props interface:
```typescript
interface PropInspectorProps {
  node: ComponentNode | null;
}
```

Implementation:
- If `node` is null, show empty state: "Select a component to inspect its props"
- Header: component name as `<ComponentName>` in bold
- Source location: `filePath:lineNumber` in small muted text, truncated to show just the filename
- Props table using MUI `Table` (size="small") or a simple div-based layout:
  - Left column: prop name in monospace
  - Right column: prop value, colored by type (string in green, number in blue, boolean in purple, expression in gray)
- For complex props (rawType === 'expression'): show the summary value inline. Per CONTEXT.md locked decision, these are expandable on click. Use a local `useState<Set<string>>` to track which prop names are expanded. When collapsed, show the summary on a single line. When expanded, show the same summary value in a visually distinct indented monospace block. The click target is the entire prop row. No re-parsing is needed — the summary value from AST is sufficient for both states.

```tsx
export function PropInspector({ node }: PropInspectorProps) {
  const [expandedProps, setExpandedProps] = useState<Set<string>>(new Set());

  // Reset expanded state when selected component changes
  useEffect(() => {
    setExpandedProps(new Set());
  }, [node?.id]);

  if (!node) {
    return (
      <Box sx={{ p: 2, color: 'text.secondary' }}>
        <Typography variant="body2">Select a component to inspect its props</Typography>
      </Box>
    );
  }

  const fileName = node.sourceFile.split('/').pop() ?? node.sourceFile;

  function togglePropExpansion(propName: string) {
    setExpandedProps((prev) => {
      const next = new Set(prev);
      if (next.has(propName)) next.delete(propName);
      else next.add(propName);
      return next;
    });
  }

  return (
    <Box sx={{ p: 1 }}>
      <Typography sx={{ fontFamily: 'monospace', fontSize: '14px', fontWeight: 600, color: 'primary.main', mb: 0.5 }}>
        {'<'}{node.componentName}{'>'}
      </Typography>
      <Typography variant="caption" color="text.secondary" sx={{ display: 'block', mb: 1 }}>
        {fileName}:{node.sourceLine}
      </Typography>

      {node.props.length === 0 ? (
        <Typography variant="body2" color="text.secondary">No props</Typography>
      ) : (
        <Box component="table" sx={{ width: '100%', borderCollapse: 'collapse', fontFamily: 'monospace', fontSize: '12px' }}>
          <tbody>
            {node.props.map((prop) => {
              const isExpression = prop.rawType === 'expression';
              const isExpanded = isExpression && expandedProps.has(prop.name);
              return (
                <React.Fragment key={prop.name}>
                  <Box
                    component="tr"
                    onClick={isExpression ? () => togglePropExpansion(prop.name) : undefined}
                    sx={{
                      '&:hover': { bgcolor: 'action.hover' },
                      cursor: isExpression ? 'pointer' : 'default',
                    }}
                  >
                    <Box component="td" sx={{ py: 0.25, pr: 1, color: 'text.secondary', verticalAlign: 'top', whiteSpace: 'nowrap' }}>
                      {isExpression && (
                        <Box component="span" sx={{ mr: 0.5, fontSize: '10px', display: 'inline-block', width: 12 }}>
                          {isExpanded ? '▼' : '▶'}
                        </Box>
                      )}
                      {prop.name}
                    </Box>
                    <Box component="td" sx={{
                      py: 0.25,
                      color: prop.rawType === 'string' ? 'success.main'
                        : prop.rawType === 'number' ? 'info.main'
                        : prop.rawType === 'boolean' ? 'secondary.main'
                        : 'text.secondary',
                      wordBreak: 'break-all',
                    }}>
                      {isExpanded ? null : prop.value}
                    </Box>
                  </Box>
                  {isExpanded && (
                    <Box component="tr">
                      <Box component="td" colSpan={2} sx={{ py: 0.5, pl: 3 }}>
                        <Box sx={{
                          fontFamily: 'monospace',
                          fontSize: '12px',
                          bgcolor: 'action.hover',
                          borderRadius: 0.5,
                          p: 1,
                          color: 'text.secondary',
                          whiteSpace: 'pre-wrap',
                          wordBreak: 'break-all',
                        }}>
                          {prop.value}
                        </Box>
                      </Box>
                    </Box>
                  )}
                </React.Fragment>
              );
            })}
          </tbody>
        </Box>
      )}
    </Box>
  );
}
```

**3. Create `src/components/InspectorPanel.tsx`**

The right sidebar panel with two tabs: "Copy" and "Components". Per CONTEXT.md locked decisions:
- Switching tabs preserves scroll position and selection state in both tabs
- Copy tab is present but content is Phase 3 placeholder
- Collapsible via toggle button

Implementation:
- Read from `useInspectorStore`: `panelOpen`, `activeTab`, `setActiveTab`, `selectedComponentId`, `hoveredComponentId`, `componentTree`, `setSelectedComponent`, `setHoveredComponent`
- If `!panelOpen`, render nothing (or a thin collapsed state — per Claude's discretion, just don't render; the toggle button in the Toolbar handles re-opening)
- Fixed width: 320px (Claude's discretion per research)
- Uses MUI `Tabs` + custom `TabPanel` with `display: none` (NOT unmount) for state preservation (per research Pattern 4, Pitfall 4)

```tsx
function TabPanel({ children, value, index }: { children: React.ReactNode; value: number; index: number }) {
  return (
    <Box role="tabpanel" sx={{ display: value === index ? 'flex' : 'none', flexDirection: 'column', flex: 1, overflow: 'auto' }}>
      {children}
    </Box>
  );
}
```

Tab indices: 0 = Copy, 1 = Components. Map from `activeTab` string to index: `copy` → 0, `components` → 1.

Layout:
```tsx
<Box sx={{ width: 320, flexShrink: 0, display: 'flex', flexDirection: 'column', borderLeft: 1, borderColor: 'divider', height: '100%' }}>
  <Tabs value={tabIndex} onChange={handleTabChange} variant="fullWidth" sx={{ borderBottom: 1, borderColor: 'divider', minHeight: 36 }}>
    <Tab label="Copy" sx={{ minHeight: 36, py: 0 }} />
    <Tab label="Components" sx={{ minHeight: 36, py: 0 }} />
  </Tabs>

  <TabPanel value={tabIndex} index={0}>
    <Box sx={{ p: 2 }}>
      <Typography variant="body2" color="text.secondary">
        Copy editing will be available in a future update.
      </Typography>
    </Box>
  </TabPanel>

  <TabPanel value={tabIndex} index={1}>
    <Box sx={{ flex: 1, display: 'flex', flexDirection: 'column', overflow: 'hidden' }}>
      {/* Component tree — upper half */}
      <Box sx={{ flex: 1, overflow: 'auto', minHeight: 0 }}>
        <ComponentTree
          tree={componentTree}
          selectedId={selectedComponentId}
          hoveredId={hoveredComponentId}
          onSelect={setSelectedComponent}
          onHover={setHoveredComponent}
        />
      </Box>
      {/* Prop inspector — lower section, shows when component selected */}
      {selectedComponentId && (
        <>
          <Divider />
          <Box sx={{ maxHeight: '40%', overflow: 'auto', flexShrink: 0 }}>
            <PropInspector node={findNodeById(componentTree, selectedComponentId)} />
          </Box>
        </>
      )}
    </Box>
  </TabPanel>
</Box>
```

Add a `findNodeById` helper that recursively searches the ComponentNode[] tree:
```typescript
function findNodeById(tree: ComponentNode[], id: string): ComponentNode | null {
  for (const node of tree) {
    if (node.id === id) return node;
    const found = findNodeById(node.children, id);
    if (found) return found;
  }
  return null;
}
```

Props interface for InspectorPanel:
```typescript
interface InspectorPanelProps {
  prototypeId: string;  // needed if panel fetches tree directly (but tree is fetched in PreviewFrame)
}
```

Actually, InspectorPanel does not need prototypeId — it reads everything from the Zustand store. Simplify to no props.

IMPORTANT: When `hoveredComponentId` changes (from tree hover), the iframe should also show the highlight. This requires sending a message TO the iframe. BUT the research recommended keeping highlight inside the iframe only. For tree-hover → iframe-highlight, we would need a new `HIGHLIGHT_COMPONENT` message from shell to iframe. This adds complexity. Per Claude's discretion: for v1, tree hover ONLY highlights in the tree, not in the iframe. Iframe hover highlights in BOTH the iframe (via the overlay inside iframe) AND the tree (via Zustand). This is a one-directional sync that's simpler and still delivers core value.
  </action>
  <verify>
    <automated>cd /Users/gyorgybokros/Projects/mq-ds-collab-tool && npx tsc --noEmit 2>&1 | tail -20 && echo "TSC OK" || echo "TSC ERRORS"</automated>
  </verify>
  <done>
    - BreakpointSwitcher shows Auto + 5 MUI breakpoints in toolbar
    - Clicking a breakpoint resizes the iframe container to that exact pixel width (not CSS scale)
    - Auto mode makes preview fill available space; fixed breakpoints show centered iframe with gray surround
    - InspectorPanel renders with Copy and Components tabs; switching tabs does not lose state
    - Components tab shows the MUI component tree hierarchy
    - Clicking a tree node shows its props in PropInspector (key-value table with source location)
    - Complex props (rawType 'expression') show expand/collapse toggle; clicking expands to a distinct monospace block
    - Hovering in iframe highlights the component in both the iframe overlay and the tree
    - Clicking in iframe selects the component in the tree and shows its props
    - Panel is hidden when `panelOpen` is false, toggle button in toolbar shows/hides it
  </done>
</task>

</tasks>

<verification>
1. Open app, click each breakpoint button — iframe resizes to exact pixel width, centered with gray surround
2. Click Auto — iframe fills all available space
3. Components tab shows the MUI hierarchy for the sample prototype (Box > Paper > Stack > etc.)
4. Click a component in the tree — PropInspector shows its props with values and source location; click a complex prop (expression type) — it expands to show value in a monospace block; click again — it collapses
5. Hover over a component in the iframe — highlight overlay appears, tree node highlights
6. Click a component in the iframe — tree auto-selects and scrolls to it, props shown
7. Switch to Copy tab, scroll down, switch back to Components — scroll position preserved
8. Click panel toggle button — panel hides/shows
9. `npm run build` passes without errors
</verification>

<success_criteria>
- Breakpoint switcher provides xs(360)/sm(600)/md(900)/lg(1200)/xl(1536) + Auto with actual iframe resizing
- Component tree displays MUI-only hierarchy matching the prototype source
- Prop inspector shows key-value pairs with type-colored values and source location
- Complex props (expression type) are expandable on click per user decision
- Tab switching preserves state (display:none pattern, not unmount)
- Iframe hover/click syncs with tree selection
- Panel is collapsible from toolbar
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-inspector-responsive-preview/02-02-SUMMARY.md`
</output>
