---
phase: 02-inspector-responsive-preview
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/ast-inspector.ts
  - src/lib/inspector-plugin.ts
  - src/stores/inspector.ts
  - src/lib/postmessage-types.ts
  - src/app/api/preview/[id]/tree/route.ts
  - src/lib/bundler.ts
  - src/app/preview/[id]/route.ts
  - public/preview-bootstrap.js
autonomous: true
requirements:
  - INSP-01
  - INSP-02

must_haves:
  truths:
    - "GET /api/preview/[id]/tree returns a ComponentNode[] JSON tree for a valid prototype"
    - "The tree contains only MUI (capitalized) components — no raw HTML elements"
    - "Each node has componentName, props array with name/value, sourceFile, and sourceLine"
    - "The bundled prototype HTML has data-inspector-id attributes on MUI component DOM elements"
    - "The iframe posts COMPONENT_HOVER and COMPONENT_SELECT messages when inspector mode is active"
  artifacts:
    - path: "src/lib/ast-inspector.ts"
      provides: "Babel-based component tree extraction"
      exports: ["extractComponentTree", "ComponentNode", "PropEntry"]
    - path: "src/lib/inspector-plugin.ts"
      provides: "Babel plugin injecting data-inspector-id attributes"
      exports: ["injectInspectorIds"]
    - path: "src/stores/inspector.ts"
      provides: "Zustand store for panel state, selected component, preview width"
      exports: ["useInspectorStore"]
    - path: "src/lib/postmessage-types.ts"
      provides: "Shared type definitions for shell<->iframe postMessage protocol"
      exports: ["ShellToIframe", "IframeToShell"]
    - path: "src/app/api/preview/[id]/tree/route.ts"
      provides: "API endpoint returning component tree JSON"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/preview/[id]/tree/route.ts"
      to: "src/lib/ast-inspector.ts"
      via: "extractComponentTree() call"
      pattern: "extractComponentTree"
    - from: "src/lib/bundler.ts"
      to: "src/lib/inspector-plugin.ts"
      via: "injectInspectorIds() pre-pass before esbuild"
      pattern: "injectInspectorIds"
    - from: "public/preview-bootstrap.js"
      to: "parent window"
      via: "postMessage COMPONENT_HOVER/COMPONENT_SELECT"
      pattern: "COMPONENT_HOVER|COMPONENT_SELECT"
---

<objective>
Build the AST-based component inspection pipeline and iframe inspector integration.

Purpose: Establish the server-side Babel AST extraction that powers the component tree and prop inspector, the Babel pre-pass that injects data-inspector-id attributes into prototype DOM, and the iframe-side inspector script that communicates hover/click events to the shell. This is the data foundation that Plan 02 UI components consume.

Output: AST inspector library, Babel injection plugin, Zustand inspector store, tree API endpoint, modified bundler with pre-pass, modified iframe bootstrap with inspector event listeners.
</objective>

<execution_context>
@/Users/gyorgybokros/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gyorgybokros/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-inspector-responsive-preview/02-RESEARCH.md

@src/lib/bundler.ts
@src/app/api/preview/[id]/bundle/route.ts
@src/app/preview/[id]/route.ts
@public/preview-bootstrap.js
@src/stores/theme.ts

<interfaces>
<!-- Key types and contracts the executor needs. -->

From src/lib/bundler.ts:
```typescript
export async function bundlePrototype(filePath: string): Promise<string>;
// Uses esbuild build() with stdin, external React/MUI, format: 'esm'
// Reads file, normalizes default export, transpiles JSX
```

From src/stores/theme.ts:
```typescript
export type ThemeMode = 'light' | 'dark' | 'system';
export function useThemeStore(): { mode: ThemeMode; cycleMode: () => void };
// Uses MUI useColorScheme() internally — NOT Zustand persist
```

From public/preview-bootstrap.js:
```javascript
// Root component handles: bundle loading, RELOAD postMessage, ErrorBoundary
// ThemeListener handles: SET_THEME postMessage -> MUI setMode()
// Uses createElement (no JSX) — runs as-is in browser
// Posts RENDER_ERROR to parent on errors
```

Existing postMessage protocol:
- Shell -> iframe: SET_THEME { type, mode }, RELOAD { type }
- Iframe -> shell: RENDER_ERROR { type, message }
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AST inspector, postMessage types, and Zustand inspector store</name>
  <files>
    src/lib/ast-inspector.ts
    src/lib/postmessage-types.ts
    src/stores/inspector.ts
  </files>
  <action>
**1. Create `src/lib/postmessage-types.ts`** — shared type definitions for the postMessage protocol.

Define types extending the Phase 1 protocol:

```typescript
import type { ComponentNode } from './ast-inspector';

// Shell -> iframe
export type ShellToIframe =
  | { type: 'SET_THEME'; mode: 'light' | 'dark' | 'system' }
  | { type: 'RELOAD' }
  | { type: 'SET_INSPECTOR_MODE'; enabled: boolean };

// Iframe -> shell
export type IframeToShell =
  | { type: 'RENDER_ERROR'; message: string }
  | { type: 'COMPONENT_TREE'; tree: ComponentNode[] }
  | { type: 'COMPONENT_HOVER'; id: string | null; rect: { top: number; left: number; width: number; height: number } | null }
  | { type: 'COMPONENT_SELECT'; id: string; rect: { top: number; left: number; width: number; height: number } };
```

**2. Create `src/lib/ast-inspector.ts`** — Babel-based component tree extraction.

Use `@babel/parser` (plugins: `['jsx', 'typescript']`) and `@babel/traverse` (both already installed as Next.js transitive deps). Follow the research pattern exactly:

- `ComponentNode` interface: `{ id, componentName, props: PropEntry[], sourceFile, sourceLine, children: ComponentNode[] }`
- `PropEntry` interface: `{ name, value (serialized display), rawType: 'string'|'number'|'boolean'|'expression'|'spread' }`
- `extractComponentTree(sourceCode: string, filePath: string): ComponentNode[]`

Key implementation details:
- ID format: `${componentName}_${line}_${col}` for uniqueness within tree
- Skip lowercase JSX elements (div, span, p) — they start with lowercase letter
- Handle `JSXMemberExpression` (e.g., `MUI.Button`) via recursive name resolution
- Handle `JSXSpreadAttribute` as `{ name: '...spread', value: '{...}', rawType: 'spread' }`
- Boolean shorthand props (`<Button disabled />`) → `{ name: 'disabled', value: 'true', rawType: 'boolean' }`
- String literal props → `{ name, value: '"text"', rawType: 'string' }`
- Numeric/boolean expression props → serialize value
- Object expressions → `'{...}'`, array expressions → `'[N items]'`, functions → `'() => ...'`
- All other expressions → `'{...}'`

CRITICAL (Pitfall 5 from research): Track skipped HTML elements correctly in the stack. When a lowercase HTML element is encountered, push a placeholder array to the stack so `exit()` pops correctly. But do NOT add the placeholder's children to the parent — only pop it on exit.

Correct pattern: Use the `JSXElement` visitor (not `JSXOpeningElement`) with `enter`/`exit` hooks. In `enter`:
- If lowercase → push `[]` placeholder to stack, return
- If uppercase → create `ComponentNode`, push to `stack[stack.length - 1]`, push `node.children` to stack

In `exit`:
- Always `stack.pop()`

This ensures HTML elements' children (which may contain MUI components) are correctly collected into the nearest MUI parent.

WAIT — the research code has a subtle issue. If we skip HTML elements, their MUI children go into the placeholder array, NOT into the parent. We need a different approach:

For skipped (HTML) elements, do NOT push a separate array. Instead, push the CURRENT parent array. This way MUI children found inside HTML elements still get added to the correct MUI parent:

```typescript
JSXElement: {
  enter(path) {
    const opening = path.node.openingElement;
    const nameNode = opening.name;
    const isHtml = nameNode.type === 'JSXIdentifier' && /^[a-z]/.test(nameNode.name);

    if (isHtml) {
      // Push the SAME parent ref — children inside this HTML element
      // will be added to the current MUI parent
      stack.push(stack[stack.length - 1]);
      return;
    }

    // ... create ComponentNode, push to current parent, push node.children
  },
  exit() {
    stack.pop();
  },
}
```

**3. Create `src/stores/inspector.ts`** — Zustand store for all Phase 2 UI state.

Use Zustand `create` (same pattern as theme.ts but with a real Zustand store, NOT wrapping MUI hooks):

```typescript
import { create } from 'zustand';
import type { ComponentNode } from '@/lib/ast-inspector';

interface InspectorState {
  // Panel
  panelOpen: boolean;
  activeTab: 'copy' | 'components';
  // Inspector
  selectedComponentId: string | null;
  hoveredComponentId: string | null;
  componentTree: ComponentNode[];
  inspectorMode: boolean;
  // Preview
  previewWidth: number | 'auto';
}

interface InspectorActions {
  togglePanel: () => void;
  setActiveTab: (tab: 'copy' | 'components') => void;
  setSelectedComponent: (id: string | null) => void;
  setHoveredComponent: (id: string | null) => void;
  setComponentTree: (tree: ComponentNode[]) => void;
  setPreviewWidth: (width: number | 'auto') => void;
  setInspectorMode: (enabled: boolean) => void;
}

export const useInspectorStore = create<InspectorState & InspectorActions>((set) => ({
  panelOpen: true,
  activeTab: 'components',
  selectedComponentId: null,
  hoveredComponentId: null,
  componentTree: [],
  inspectorMode: true,
  previewWidth: 'auto',
  togglePanel: () => set((s) => ({ panelOpen: !s.panelOpen })),
  setActiveTab: (tab) => set({ activeTab: tab }),
  setSelectedComponent: (id) => set({ selectedComponentId: id }),
  setHoveredComponent: (id) => set({ hoveredComponentId: id }),
  setComponentTree: (tree) => set({ componentTree: tree }),
  setPreviewWidth: (width) => set({ previewWidth: width }),
  setInspectorMode: (enabled) => set({ inspectorMode: enabled }),
}));
```

Default `panelOpen: true`, `activeTab: 'components'`, `inspectorMode: true`, `previewWidth: 'auto'`.
  </action>
  <verify>
    <automated>cd /Users/gyorgybokros/Projects/mq-ds-collab-tool && npx tsx -e "
      const { extractComponentTree } = require('./src/lib/ast-inspector');
      const tree = extractComponentTree('<Box><Typography variant=\"h1\">Hello</Typography><div><Button>Click</Button></div></Box>', 'test.jsx');
      const flat = JSON.stringify(tree);
      console.assert(flat.includes('Box'), 'Box found');
      console.assert(flat.includes('Typography'), 'Typography found');
      console.assert(flat.includes('Button'), 'Button found');
      console.assert(!flat.includes('\"div\"'), 'div excluded');
      console.assert(flat.includes('variant'), 'props extracted');
      console.log('AST inspector OK');
    " 2>&1 || echo "VERIFY: check manually with npx tsx"</automated>
  </verify>
  <done>
    - `ast-inspector.ts` exports `extractComponentTree`, `ComponentNode`, `PropEntry`
    - `postmessage-types.ts` exports `ShellToIframe`, `IframeToShell` covering all Phase 1+2 message types
    - `stores/inspector.ts` exports `useInspectorStore` with panel, inspector, and preview state
    - AST extraction correctly filters HTML elements, preserves MUI hierarchy, extracts props with type info
  </done>
</task>

<task type="auto">
  <name>Task 2: Tree API endpoint, Babel injection pre-pass, and iframe inspector script</name>
  <files>
    src/lib/inspector-plugin.ts
    src/app/api/preview/[id]/tree/route.ts
    src/lib/bundler.ts
    src/app/preview/[id]/route.ts
    public/preview-bootstrap.js
  </files>
  <action>
**1. Create `src/lib/inspector-plugin.ts`** — Babel transform that injects `data-inspector-id` attributes.

This runs as a pre-pass BEFORE esbuild. Since `@babel/core` is NOT installed (confirmed), use `@babel/parser` + `@babel/traverse` + `@babel/generator` (all three ARE installed as transitive deps).

```typescript
import { parse } from '@babel/parser';
import _traverse from '@babel/traverse';
import _generate from '@babel/generator';
import * as t from '@babel/types';

// Handle CJS default export interop for @babel/traverse and @babel/generator
const traverse = (typeof _traverse === 'function' ? _traverse : (_traverse as any).default) as typeof _traverse;
const generate = (typeof _generate === 'function' ? _generate : (_generate as any).default) as typeof _generate;

export function injectInspectorIds(sourceCode: string, filePath: string): string {
  const ast = parse(sourceCode, {
    sourceType: 'module',
    plugins: ['jsx', 'typescript'],
  });

  traverse(ast, {
    JSXOpeningElement(path) {
      const nameNode = path.node.name;
      if (nameNode.type === 'JSXIdentifier' && /^[a-z]/.test(nameNode.name)) return;

      const componentName = nameNode.type === 'JSXIdentifier'
        ? nameNode.name
        : nameNode.type === 'JSXMemberExpression'
        ? `${(nameNode.object as any).name}.${nameNode.property.name}`
        : 'Unknown';

      const line = path.node.loc?.start.line ?? 0;
      const col = path.node.loc?.start.column ?? 0;
      const id = `${componentName}_${line}_${col}`;

      // Don't add if already has data-inspector-id
      const hasId = path.node.attributes.some(
        (attr) => attr.type === 'JSXAttribute' && attr.name.name === 'data-inspector-id'
      );
      if (hasId) return;

      path.node.attributes.push(
        t.jsxAttribute(
          t.jsxIdentifier('data-inspector-id'),
          t.stringLiteral(id)
        )
      );
    },
  });

  const output = generate(ast, { retainLines: true });
  return output.code;
}
```

IMPORTANT: The CJS default export interop is needed because `@babel/traverse` and `@babel/generator` may export as `{ default: fn }` when imported with ESM syntax from CJS modules in Next.js server context.

**2. Modify `src/lib/bundler.ts`** — add Babel pre-pass before esbuild.

Add import of `injectInspectorIds` from `./inspector-plugin`. In `bundlePrototype()`, after `ensureDefaultExport()` and before `esbuild.build()`, run the pre-pass:

```typescript
import { injectInspectorIds } from './inspector-plugin';

export async function bundlePrototype(filePath: string): Promise<string> {
  const contents = await readFile(filePath, 'utf-8');
  const normalizedContents = ensureDefaultExport(contents);

  // Babel pre-pass: inject data-inspector-id attributes on MUI components
  const instrumentedContents = injectInspectorIds(normalizedContents, filePath);

  const result = await esbuild.build({
    stdin: {
      contents: instrumentedContents,  // <-- use instrumented source
      // ...rest stays the same
```

Also export a new `getSourceCode` helper that reads + normalizes (but does NOT inject or bundle) for the tree endpoint:

```typescript
export async function getPrototypeSource(filePath: string): Promise<string> {
  const contents = await readFile(filePath, 'utf-8');
  return ensureDefaultExport(contents);
}
```

**3. Create `src/app/api/preview/[id]/tree/route.ts`** — GET endpoint returning ComponentNode[] JSON.

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { extractComponentTree } from '@/lib/ast-inspector';
import { getPrototypeSource } from '@/lib/bundler';
import path from 'path';

export const dynamic = 'force-dynamic';

export async function GET(
  _req: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  const protoDir = process.env.PROTOTYPES_DIR ?? path.join(process.cwd(), 'prototypes');
  const filePath = path.join(protoDir, id, 'index.jsx');

  try {
    const source = await getPrototypeSource(filePath);
    const tree = extractComponentTree(source, filePath);
    return NextResponse.json(tree);
  } catch (err: unknown) {
    const message = err instanceof Error ? err.message : String(err);
    return NextResponse.json({ error: message }, { status: 422 });
  }
}
```

**4. Modify `public/preview-bootstrap.js`** — add inspector event listeners.

Add an inspector section AFTER the existing Root component but BEFORE the mount code. The inspector script:

a) Listens for `SET_INSPECTOR_MODE` postMessage to enable/disable inspector mode.

b) When inspector mode is active:
   - On `mouseover`: walk up from `event.target` to find nearest `[data-inspector-id]`, get `getBoundingClientRect()`, post `COMPONENT_HOVER` to parent with id and rect.
   - On `mouseout`: post `COMPONENT_HOVER` with `id: null, rect: null`.
   - On `click` (when inspector mode is on): `event.preventDefault()`, `event.stopPropagation()`, walk up to find `[data-inspector-id]`, post `COMPONENT_SELECT` with id and rect.

c) Adds CSS for hover highlight INSIDE the iframe: when hovering an inspectable element, apply a semi-transparent outline via a dynamically positioned div.

Implementation — add this code block BEFORE the mount section (`const rootElement = ...`):

```javascript
// ─── Inspector mode — hover/click to identify components ─────────────────────
let inspectorEnabled = true; // start enabled per default store state
let highlightOverlay = null;

function ensureOverlay() {
  if (highlightOverlay) return highlightOverlay;
  highlightOverlay = document.createElement('div');
  highlightOverlay.style.cssText = 'position:fixed;pointer-events:none;border:2px solid #1976d2;background:rgba(25,118,210,0.08);z-index:99999;display:none;transition:all 0.05s ease-out;';
  document.body.appendChild(highlightOverlay);
  return highlightOverlay;
}

function findInspectorTarget(el) {
  while (el && el !== document.body) {
    if (el.dataset && el.dataset.inspectorId) return el;
    el = el.parentElement;
  }
  return null;
}

document.addEventListener('mouseover', function(e) {
  if (!inspectorEnabled) return;
  const target = findInspectorTarget(e.target);
  if (!target) {
    const overlay = ensureOverlay();
    overlay.style.display = 'none';
    window.parent.postMessage({ type: 'COMPONENT_HOVER', id: null, rect: null }, '*');
    return;
  }
  const rect = target.getBoundingClientRect();
  const overlay = ensureOverlay();
  overlay.style.top = rect.top + 'px';
  overlay.style.left = rect.left + 'px';
  overlay.style.width = rect.width + 'px';
  overlay.style.height = rect.height + 'px';
  overlay.style.display = 'block';
  window.parent.postMessage({
    type: 'COMPONENT_HOVER',
    id: target.dataset.inspectorId,
    rect: { top: rect.top, left: rect.left, width: rect.width, height: rect.height }
  }, '*');
}, true);

document.addEventListener('mouseout', function(e) {
  if (!inspectorEnabled) return;
  if (e.relatedTarget && document.contains(e.relatedTarget)) return;
  const overlay = ensureOverlay();
  overlay.style.display = 'none';
  window.parent.postMessage({ type: 'COMPONENT_HOVER', id: null, rect: null }, '*');
}, true);

document.addEventListener('click', function(e) {
  if (!inspectorEnabled) return;
  const target = findInspectorTarget(e.target);
  if (!target) return;
  e.preventDefault();
  e.stopPropagation();
  const rect = target.getBoundingClientRect();
  window.parent.postMessage({
    type: 'COMPONENT_SELECT',
    id: target.dataset.inspectorId,
    rect: { top: rect.top, left: rect.left, width: rect.width, height: rect.height }
  }, '*');
}, true);

// Listen for SET_INSPECTOR_MODE from parent
window.addEventListener('message', function(event) {
  if (event.data?.type === 'SET_INSPECTOR_MODE') {
    inspectorEnabled = !!event.data.enabled;
    if (!inspectorEnabled && highlightOverlay) {
      highlightOverlay.style.display = 'none';
    }
  }
});
```

Also add a `COMPONENT_TREE` message post after successful bundle load. In the existing Root component's `load` callback, after `setState` with the Component, post the tree data. BUT the tree comes from the server API, not from the iframe. So instead, add to the EXISTING `load` function, after successful import, a fetch to the tree endpoint:

Actually, the tree should be fetched by the SHELL, not the iframe. The shell fetches `/api/preview/[id]/tree` and stores in Zustand. This is simpler and avoids complexity in the iframe. Remove the `COMPONENT_TREE` postMessage from the plan — the shell fetches the tree directly.

**5. Modify `src/app/preview/[id]/route.ts`** — no changes needed. The data-inspector-id attributes are already injected by the bundler pre-pass, so they appear in the prototype code that runs in the iframe. The preview route HTML does not need modification.

IMPORTANT: The `data-inspector-id` attributes are JSX props that get rendered as HTML `data-inspector-id` attributes by React. This works because React passes through `data-*` props to the DOM. However, the attribute name in the DOM is `data-inspector-id`, which in `element.dataset` becomes `inspectorId` (camelCase per HTMLElement.dataset spec). The `findInspectorTarget` function correctly uses `el.dataset.inspectorId`.
  </action>
  <verify>
    <automated>cd /Users/gyorgybokros/Projects/mq-ds-collab-tool && npm run build 2>&1 | tail -20 && echo "BUILD OK" || echo "BUILD FAILED"</automated>
  </verify>
  <done>
    - GET /api/preview/[id]/tree returns valid ComponentNode[] JSON for the sample prototype
    - bundler.ts runs Babel pre-pass injecting data-inspector-id attributes before esbuild
    - preview-bootstrap.js has inspector mouseover/click listeners that post COMPONENT_HOVER/COMPONENT_SELECT
    - The highlight overlay in the iframe visually outlines hovered MUI components
    - Build completes without errors
  </done>
</task>

</tasks>

<verification>
1. `curl http://localhost:3000/api/preview/sample/tree` returns JSON array of ComponentNode objects
2. View page source of `/preview/sample` bundle — confirm `data-inspector-id` attributes present on MUI component output
3. Hover over a component in the iframe — check browser console for COMPONENT_HOVER postMessage (via event listener in shell)
4. `npm run build` passes without errors
</verification>

<success_criteria>
- The AST pipeline correctly extracts MUI component hierarchy from Claude-generated prototype source
- The tree API endpoint returns accurate component names, props, and source locations
- The Babel pre-pass injects data-inspector-id without breaking the prototype rendering
- The iframe inspector script sends hover/select messages to the parent shell
- All new code follows existing project patterns (Route Handler, Zustand store, postMessage protocol)
</success_criteria>

<output>
After completion, create `.planning/phases/02-inspector-responsive-preview/02-01-SUMMARY.md`
</output>
