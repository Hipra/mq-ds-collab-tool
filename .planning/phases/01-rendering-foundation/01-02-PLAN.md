---
phase: 01-rendering-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/app/(shell)/layout.tsx
  - src/app/(shell)/page.tsx
  - src/stores/theme.ts
  - src/components/PreviewFrame.tsx
  - src/components/Toolbar.tsx
  - src/components/ErrorDisplay.tsx
  - src/lib/watcher.ts
  - src/app/api/watch/route.ts
autonomous: false
requirements:
  - REND-03
  - REND-02

must_haves:
  truths:
    - "The app shell shows a minimal toolbar with the prototype name and a three-state theme toggle (Light / Dark / System)"
    - "Clicking the toggle cycles through Light -> Dark -> System, and both the app shell AND the iframe prototype switch theme together"
    - "The default theme mode follows the OS system preference (prefers-color-scheme)"
    - "The theme preference is persisted globally (survives page refresh) and is not per-prototype"
    - "When a prototype file is saved, the preview updates automatically without manual refresh (hot reload via SSE)"
    - "When the prototype has an error, the shell shows a loading/error state appropriately — the app itself does not crash"
  artifacts:
    - path: "src/stores/theme.ts"
      provides: "Zustand store for theme mode (light/dark/system) with localStorage persistence"
      exports: ["useThemeStore"]
    - path: "src/components/PreviewFrame.tsx"
      provides: "iframe wrapper component with postMessage bridge for theme sync and reload"
      exports: ["PreviewFrame"]
    - path: "src/components/Toolbar.tsx"
      provides: "Minimal toolbar with prototype name and three-state theme toggle"
      exports: ["Toolbar"]
    - path: "src/app/(shell)/layout.tsx"
      provides: "App shell layout with MUI ThemeProvider (cssVariables + colorSchemes)"
    - path: "src/app/api/watch/route.ts"
      provides: "SSE endpoint streaming file change events from chokidar"
      exports: ["GET"]
    - path: "src/lib/watcher.ts"
      provides: "Chokidar file watcher singleton with subscriber pattern"
      exports: ["getWatcher", "subscribers"]
  key_links:
    - from: "src/components/Toolbar.tsx"
      to: "src/stores/theme.ts"
      via: "useThemeStore() for mode state and setMode"
      pattern: "useThemeStore"
    - from: "src/components/PreviewFrame.tsx"
      to: "iframe contentWindow.postMessage"
      via: "SET_THEME message when theme mode changes"
      pattern: "postMessage.*SET_THEME"
    - from: "src/components/PreviewFrame.tsx"
      to: "/api/watch SSE"
      via: "EventSource subscribes to file changes, sends RELOAD postMessage to iframe"
      pattern: "EventSource.*api/watch"
    - from: "src/app/api/watch/route.ts"
      to: "src/lib/watcher.ts"
      via: "getWatcher() + subscribers pattern"
      pattern: "import.*watcher"
---

<objective>
Build the app shell with a minimal toolbar (prototype name + three-state dark/light/system toggle), embed the preview iframe with a postMessage bridge for theme synchronization, and add hot reload via SSE file watching — completing the full rendering experience.

Purpose: This connects the rendering pipeline (Plan 01) to a usable developer experience. The designer working in Claude Code sees their changes instantly, can toggle dark/light mode, and sees errors without the app crashing.

Output: A complete app shell at `/` that embeds the preview iframe, syncs theme mode between shell and prototype, auto-reloads on file changes, and handles errors gracefully.
</objective>

<execution_context>
@/Users/gyorgybokros/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gyorgybokros/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-rendering-foundation/01-RESEARCH.md
@.planning/phases/01-rendering-foundation/01-CONTEXT.md
@.planning/phases/01-rendering-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zustand theme store and app shell layout with MUI ThemeProvider</name>
  <files>
    src/stores/theme.ts
    src/app/(shell)/layout.tsx
    src/app/(shell)/page.tsx
  </files>
  <action>
**Create `src/stores/theme.ts`:**
- Use Zustand with `persist` middleware for localStorage persistence
- Store shape: `{ mode: 'light' | 'dark' | 'system', setMode: (mode) => void, cycleMode: () => void }`
- `cycleMode()` rotates: light -> dark -> system -> light
- Persist key: `mq-ds-theme-mode`
- Default mode: `'system'` (per CONTEXT.md: follows prefers-color-scheme)
- This is a GLOBAL setting, not per-prototype (per CONTEXT.md)

**Create `src/app/(shell)/layout.tsx`:**
- This is the app shell layout — wraps all non-preview pages
- Use MUI ThemeProvider with the same theme config as the iframe: `createTheme({ cssVariables: true, colorSchemes: { light: true, dark: true } })`
- Import the theme from `src/lib/theme.ts` (created in Plan 01)
- Wrap children in `ThemeProvider` + `CssBaseline`
- IMPORTANT: The shell ThemeProvider and the iframe ThemeProvider are SEPARATE instances. Theme changes must be applied to BOTH — the shell via Zustand + useColorScheme, the iframe via postMessage. Per CONTEXT.md: "the whole app shell AND the prototype switch together"
- Include an `InitColorSchemeScript` or equivalent to prevent flash of unstyled content on initial load. MUI v6 with cssVariables: true handles this — the `data-mui-color-scheme` attribute on `<html>` is set before React hydrates.
- Mark this as a client component (`'use client'`) since it uses ThemeProvider and state

**Create `src/app/(shell)/page.tsx`:**
- Main app page — client component
- Layout: Full viewport height, flex column
  - Top: `<Toolbar />` component (created in Task 2)
  - Main area: `<PreviewFrame />` component (created in Task 2) — takes remaining space
- For now, hardcode `prototypeId = 'sample'` — prototype selection will come in a later phase
- Pass `prototypeId` to both Toolbar (for name display) and PreviewFrame (for iframe URL)

**Shell ThemeProvider syncing with Zustand store:**
Create a `ThemeSyncProvider` wrapper component (can be in layout.tsx or a separate file) that:
1. Reads `mode` from `useThemeStore()`
2. Calls `setMode(mode)` from MUI's `useColorScheme()` whenever the Zustand mode changes
3. This keeps the shell's MUI theme in sync with the global store
4. Handle `mode === undefined` on first render (MUI v6 returns undefined initially to avoid hydration mismatch)
  </action>
  <verify>
    <automated>npx tsc --noEmit src/stores/theme.ts src/app/\(shell\)/layout.tsx src/app/\(shell\)/page.tsx 2>&1 | head -20</automated>
  </verify>
  <done>
- Zustand store persists theme mode to localStorage under `mq-ds-theme-mode`
- Default mode is `'system'`
- App shell layout renders with MUI ThemeProvider using cssVariables + colorSchemes
- Shell page shows toolbar area and preview frame area in a flex column layout
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Toolbar with three-state toggle, PreviewFrame with postMessage bridge, and SSE file watcher</name>
  <files>
    src/components/Toolbar.tsx
    src/components/PreviewFrame.tsx
    src/components/ErrorDisplay.tsx
    src/lib/watcher.ts
    src/app/api/watch/route.ts
  </files>
  <action>
**Create `src/components/Toolbar.tsx`:**
- Client component (`'use client'`)
- Minimal toolbar (per CONTEXT.md: "the focus should be on the prototype, not the tool")
- Props: `{ prototypeName: string }`
- Contents (left to right):
  - Prototype name as Typography
  - Spacer (flex: 1)
  - Three-state theme toggle button using MUI IconButton
    - Light mode: `LightMode` icon (from `@mui/icons-material`)
    - Dark mode: `DarkMode` icon
    - System mode: `SettingsBrightness` icon
    - onClick calls `useThemeStore().cycleMode()`
    - Display current mode label or tooltip
- Use MUI `AppBar` or a simple `Box` with `borderBottom` — keep it minimal
- Handle `mode === undefined` gracefully (MUI v6 first render issue — show nothing or a placeholder icon)

Note: Install `@mui/icons-material` if not already present: `npm install @mui/icons-material`

**Create `src/components/PreviewFrame.tsx`:**
- Client component (`'use client'`)
- Props: `{ prototypeId: string }`
- Renders an `<iframe>` pointing to `/preview/${prototypeId}`
- iframe attributes: `sandbox="allow-scripts allow-same-origin"` (same-origin needed for Blob URL imports — security tradeoff documented in research, acceptable for Phase 1 since prototypes are local Claude Code output only)
- Style: `width: 100%, flex: 1, border: none`
- useRef for iframe element
- **Theme sync via postMessage:**
  - Watch `useThemeStore().mode` with useEffect
  - When mode changes, send `{ type: 'SET_THEME', mode }` to `iframeRef.current.contentWindow.postMessage()`
  - Wait for iframe onLoad before sending initial theme — otherwise postMessage is lost
- **Hot reload via SSE:**
  - On mount, create `new EventSource('/api/watch')`
  - On message, check if the changed file path includes the current `prototypeId`
  - If yes, send `{ type: 'RELOAD' }` to the iframe via postMessage (the bootstrap script handles re-importing the bundle)
  - Clean up EventSource on unmount
- **Error handling from iframe:**
  - Listen for `message` events from iframe
  - If `event.data.type === 'RENDER_ERROR'`, display error state (can use ErrorDisplay component or just set state)
  - Clear error state on successful reload
- Loading state: Show a spinner (per CONTEXT.md: spinner not skeleton) while iframe is loading. Use MUI CircularProgress. Switch to iframe content on iframe onLoad event.

**Create `src/components/ErrorDisplay.tsx`:**
- Reusable error display component for the shell side
- Props: `{ message: string, onRetry?: () => void }`
- Shows error message in a Box with `color: error.main`, monospace font for the error text
- Retry button if `onRetry` provided (per CONTEXT.md: retry button alongside error message)
- Used by PreviewFrame when it receives RENDER_ERROR from the iframe

**Create `src/lib/watcher.ts`:**
- Export `getWatcher()` function that returns a singleton chokidar watcher
- Export `subscribers` Set for SSE connections to register callbacks
- Watch directory: `process.env.PROTOTYPES_DIR ?? './prototypes'`
- Options: `{ ignoreInitial: true }`
- Events: `change` and `add` — notify all subscribers with the file path
- Use chokidar v4 (CommonJS compatible, Node 18+ safe per research open question #3)

**Create `src/app/api/watch/route.ts`:**
- Export `dynamic = 'force-dynamic'` (prevent caching)
- Export async `GET` handler
- Call `getWatcher()` to ensure watcher is running
- Create `ReadableStream` that:
  - Registers a subscriber callback
  - On file change: encode SSE event `data: {"file": "path"}\n\n`
  - On request abort (`req.signal.addEventListener('abort')`): remove subscriber
- Return Response with headers: `Content-Type: text/event-stream`, `Cache-Control: no-cache`, `Connection: keep-alive`
  </action>
  <verify>
    <automated>npx tsc --noEmit src/components/Toolbar.tsx src/components/PreviewFrame.tsx src/components/ErrorDisplay.tsx src/lib/watcher.ts src/app/api/watch/route.ts 2>&1 | head -20</automated>
  </verify>
  <done>
- Toolbar shows prototype name and a three-state theme toggle (Light/Dark/System icons)
- Clicking the toggle cycles modes and persists to localStorage
- PreviewFrame embeds `/preview/[id]` in a sandboxed iframe
- Theme changes in the shell are sent to the iframe via postMessage SET_THEME
- Both shell and iframe switch theme simultaneously
- SSE endpoint streams file change events when prototypes are modified
- PreviewFrame auto-reloads iframe on relevant file changes
- Loading state shows spinner, errors show ErrorDisplay with retry
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify the complete rendering pipeline</name>
  <files>N/A — verification only</files>
  <action>
Human verification checkpoint. No automated action — the user tests the complete rendering pipeline manually.

**What was built:**
Complete Phase 1 rendering pipeline:
- esbuild transpiles JSX to ESM on the server
- Preview page renders MUI prototype in a standalone iframe with correct styling
- App shell embeds the preview with toolbar (prototype name + theme toggle)
- Dark/Light/System toggle switches both shell and prototype
- File changes trigger automatic preview reload via SSE
- Errors are caught and displayed with retry option

**How to verify:**
1. Start the dev server: `npm run dev`
2. Open `http://localhost:3000` — you should see the app shell with a toolbar and the sample prototype rendered below
3. **Theme toggle test:**
   - Click the theme toggle icon in the toolbar
   - Verify it cycles: Light (sun icon) -> Dark (moon icon) -> System (brightness icon)
   - In Dark mode: both the toolbar background AND the prototype inside the iframe should have dark backgrounds
   - In Light mode: both should be light
   - In System mode: follows your OS preference
4. **Persistence test:**
   - Set to Dark mode, refresh the page — should still be Dark
5. **Hot reload test:**
   - Edit `prototypes/sample/index.jsx` — change a button label or add a component
   - Save the file — the preview should update automatically without manual refresh
6. **Error handling test:**
   - Introduce a syntax error in `prototypes/sample/index.jsx` (e.g., remove a closing tag)
   - The preview should show an error message, not crash the app
   - Fix the error and save — preview should recover
7. **Direct preview test:**
   - Open `http://localhost:3000/preview/sample` directly — should render the prototype standalone (no toolbar)

**Resume signal:** Type "approved" or describe issues to fix
  </action>
  <verify>
    <automated>curl -s -o /dev/null -w "%{http_code}" http://localhost:3000 2>/dev/null || echo "Dev server not running"</automated>
  </verify>
  <done>
- User confirms: app shell renders with toolbar + embedded preview
- User confirms: theme toggle cycles Light/Dark/System and both shell + iframe switch
- User confirms: theme persists across refresh
- User confirms: file changes trigger auto-reload
- User confirms: errors are handled gracefully with retry
  </done>
</task>

</tasks>

<verification>
1. `npm run dev` starts without errors
2. `http://localhost:3000` shows the app shell with toolbar + embedded preview
3. Theme toggle cycles through Light/Dark/System and affects both shell and iframe
4. Theme preference survives page refresh (localStorage persistence)
5. Default theme follows OS preference (System mode)
6. Editing and saving a prototype file triggers auto-reload in the preview
7. Prototype errors are caught and displayed with retry, not crashing the app
8. `http://localhost:3000/preview/sample` works standalone
</verification>

<success_criteria>
- Three-state theme toggle (Light/Dark/System) works in the toolbar
- Shell and iframe theme switch simultaneously via postMessage bridge
- Theme mode persisted globally in localStorage
- Default follows system preference
- File watcher + SSE enables hot reload on prototype file save
- Errors handled gracefully with retry option
- Toolbar is minimal — prototype name + toggle, nothing else
</success_criteria>

<output>
After completion, create `.planning/phases/01-rendering-foundation/01-02-SUMMARY.md`
</output>
